<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>tests.test_backing_image API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tests.test_backing_image</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tests.test_backing_image.backing_image_basic_operation_test"><code class="name flex">
<span>def <span class="ident">backing_image_basic_operation_test</span></span>(<span>client, volume_name, bi_name, bi_url)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backing_image_basic_operation_test(client, volume_name, bi_name, bi_url):  # NOQA
    &#34;&#34;&#34;
    Test Backing Image APIs.

    1. Create a backing image.
    2. Create and attach a Volume with the backing image set.
    3. Verify that the all disk states in the backing image are &#34;downloaded&#34;.
    4. Try to use the API to manually clean up one disk for the backing image
       but get failed.
    5. Try to use the API to directly delete the backing image
       but get failed.
    6. Delete the volume.
    7. Use the API to manually clean up one disk for the backing image
    8. Delete the backing image.
    &#34;&#34;&#34;

    volume = create_and_check_volume(client, volume_name,
                                     num_of_replicas=3,
                                     size=str(BACKING_IMAGE_EXT4_SIZE),
                                     backing_image=bi_name)
    lht_host_id = get_self_host_id()
    volume.attach(hostId=lht_host_id)
    volume = wait_for_volume_healthy(client, volume_name)
    assert volume.backingImage == bi_name
    assert volume.size == str(BACKING_IMAGE_EXT4_SIZE)

    random_disk_id = &#34;&#34;
    backing_image = client.by_id_backing_image(bi_name)
    assert backing_image.sourceType == BACKING_IMAGE_SOURCE_TYPE_DOWNLOAD
    assert backing_image.parameters[&#34;url&#34;] == bi_url
    assert backing_image.currentChecksum != &#34;&#34;
    assert not backing_image.deletionTimestamp
    assert len(backing_image.diskFileStatusMap) == 3
    for disk_id, status in iter(backing_image.diskFileStatusMap.items()):
        assert status.state == BACKING_IMAGE_STATE_READY
        random_disk_id = disk_id
    assert random_disk_id != &#39;&#39;

    with pytest.raises(Exception):
        backing_image.backingImageCleanup(disks=[random_disk_id])
    with pytest.raises(Exception):
        client.delete(backing_image)

    client.delete(volume)
    wait_for_volume_delete(client, volume_name)

    backing_image = client.by_id_backing_image(bi_name)
    backing_image.backingImageCleanup(disks=[random_disk_id])
    backing_image = wait_for_backing_image_disk_cleanup(
        client, bi_name, random_disk_id)
    client.delete(backing_image)</code></pre>
</details>
<div class="desc"><p>Test Backing Image APIs.</p>
<ol>
<li>Create a backing image.</li>
<li>Create and attach a Volume with the backing image set.</li>
<li>Verify that the all disk states in the backing image are "downloaded".</li>
<li>Try to use the API to manually clean up one disk for the backing image
but get failed.</li>
<li>Try to use the API to directly delete the backing image
but get failed.</li>
<li>Delete the volume.</li>
<li>Use the API to manually clean up one disk for the backing image</li>
<li>Delete the backing image.</li>
</ol></div>
</dd>
<dt id="tests.test_backing_image.backing_image_cleanup"><code class="name flex">
<span>def <span class="ident">backing_image_cleanup</span></span>(<span>core_api, client)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backing_image_cleanup(core_api, client): # NOQA
    # Step 1
    backing_img1_name = &#39;bi-test1&#39;
    create_backing_image_with_matching_url(
            client, backing_img1_name, BACKING_IMAGE_QCOW2_URL)

    backing_img2_name = &#39;bi-test2&#39;
    create_backing_image_with_matching_url(
            client, backing_img2_name, BACKING_IMAGE_RAW_URL)

    # Step 2
    lht_host_id = get_self_host_id()
    volume1 = create_and_check_volume(client, &#34;vol-1&#34;,
                                      size=str(1 * Gi),
                                      backing_image=backing_img1_name)

    volume2 = create_and_check_volume(client, &#34;vol-2&#34;,
                                      size=str(1 * Gi),
                                      backing_image=backing_img2_name)

    # Step 3
    volume1.attach(hostId=lht_host_id)
    volume1 = wait_for_volume_healthy(client, volume1.name)
    volume2.attach(hostId=lht_host_id)
    volume2 = wait_for_volume_healthy(client, volume2.name)
    assert volume1.backingImage == backing_img1_name
    assert volume2.backingImage == backing_img2_name

    # Step 4
    cleanup_all_volumes(client)
    cleanup_all_backing_images(client)

    # Step 5
    for i in range(RETRY_EXEC_COUNTS):
        exist = False
        pods = core_api.list_namespaced_pod(LONGHORN_NAMESPACE)
        for pod in pods.items:
            if &#34;backing-image-manager&#34; in pod.metadata.name:
                exist = True
                time.sleep(RETRY_INTERVAL)
                continue
        if exist is False:
            break

    assert exist is False</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.backing_image_content_test"><code class="name flex">
<span>def <span class="ident">backing_image_content_test</span></span>(<span>client, volume_name_prefix, bi_name, bi_url)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backing_image_content_test(client, volume_name_prefix, bi_name, bi_url):  # NOQA
    &#34;&#34;&#34;
    Verify the content of the Backing Image is accessible and read-only for
    all volumes.

    1. Create a backing image. (Done by the caller)
    2. Create a Volume with the backing image set then attach it to host node.
    3. Verify that the all disk states in the backing image are &#34;downloaded&#34;.
    4. Verify volume can be directly mounted and there is already data in the
       filesystem due to the backing image.
    5. Verify the volume r/w.
    6. Launch one more volume with the same backing image.
    7. Verify the data content of the new volume is the same as the data in
       step 4.
    5. Do cleanup. (Done by the caller)
    &#34;&#34;&#34;
    lht_host_id = get_self_host_id()

    volume_name1 = volume_name_prefix + &#34;-1&#34;
    volume1 = create_and_check_volume(client, volume_name1,
                                      num_of_replicas=3,
                                      size=str(BACKING_IMAGE_EXT4_SIZE),
                                      backing_image=bi_name)
    volume1.attach(hostId=lht_host_id)
    volume1 = wait_for_volume_healthy(client, volume_name1)
    assert volume1.backingImage == bi_name
    assert volume1.size == str(BACKING_IMAGE_EXT4_SIZE)

    backing_image = client.by_id_backing_image(bi_name)
    assert backing_image.sourceType == BACKING_IMAGE_SOURCE_TYPE_DOWNLOAD
    assert backing_image.parameters[&#34;url&#34;] == bi_url
    assert backing_image.currentChecksum != &#34;&#34;
    assert not backing_image.deletionTimestamp
    assert len(backing_image.diskFileStatusMap) == 3
    for disk_id, status in iter(backing_image.diskFileStatusMap.items()):
        assert status.state == BACKING_IMAGE_STATE_READY

    # Since there is already a filesystem with data in the backing image,
    # we can directly mount and access the volume without `mkfs`.
    dev1 = get_volume_endpoint(volume1)
    mount_path1 = os.path.join(DIRECTORY_PATH, volume_name1)
    mount_disk(dev1, mount_path1)
    output1 = subprocess.check_output([&#34;ls&#34;, mount_path1])
    # The following random write may crash the filesystem of volume1,
    # need to umount it here
    cleanup_host_disk(volume_name1)

    # Verify r/w for the volume with a backing image
    data = write_volume_random_data(volume1)
    check_volume_data(volume1, data)

    volume_name2 = volume_name_prefix + &#34;-2&#34;
    volume2 = create_and_check_volume(client, volume_name2,
                                      num_of_replicas=3,
                                      size=str(BACKING_IMAGE_EXT4_SIZE),
                                      backing_image=bi_name)
    volume2.attach(hostId=lht_host_id)
    volume2 = wait_for_volume_healthy(client, volume_name2)
    assert volume1.backingImage == bi_name
    assert volume1.size == str(BACKING_IMAGE_EXT4_SIZE)
    dev2 = get_volume_endpoint(volume2)
    mount_path2 = os.path.join(DIRECTORY_PATH, volume_name2)
    mount_disk(dev2, mount_path2)
    output2 = subprocess.check_output([&#34;ls&#34;, mount_path2])
    # The output is the content of the backing image, which should keep
    # unchanged
    assert output2 == output1

    cleanup_host_disk(volume_name2)</code></pre>
</details>
<div class="desc"><p>Verify the content of the Backing Image is accessible and read-only for
all volumes.</p>
<ol>
<li>Create a backing image. (Done by the caller)</li>
<li>Create a Volume with the backing image set then attach it to host node.</li>
<li>Verify that the all disk states in the backing image are "downloaded".</li>
<li>Verify volume can be directly mounted and there is already data in the
filesystem due to the backing image.</li>
<li>Verify the volume r/w.</li>
<li>Launch one more volume with the same backing image.</li>
<li>Verify the data content of the new volume is the same as the data in
step 4.</li>
<li>Do cleanup. (Done by the caller)</li>
</ol></div>
</dd>
<dt id="tests.test_backing_image.test_backing_image_auto_resync"><code class="name flex">
<span>def <span class="ident">test_backing_image_auto_resync</span></span>(<span>bi_url, client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
@pytest.mark.parametrize(&#34;bi_url&#34;, [BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL]) # NOQA
def test_backing_image_auto_resync(bi_url, client, volume_name):  # NOQA
    &#34;&#34;&#34;
    1. Create a backing image.
    2. Create and attach a 3-replica volume using the backing image.
    3. Wait for the attachment complete.
    4. Manually remove the backing image on the current node.
    5. Wait for the file state in the disk/on this node become failed.
    6. Wait for the file recovering automatically.
    7. Validate the volume.
    &#34;&#34;&#34;
    # Step 1
    create_backing_image_with_matching_url(
              client, BACKING_IMAGE_NAME, bi_url)

    # Step 2
    volume = create_and_check_volume(client, volume_name,
                                     num_of_replicas=3,
                                     size=str(BACKING_IMAGE_EXT4_SIZE),
                                     backing_image=BACKING_IMAGE_NAME)

    # Step 3
    lht_host_id = get_self_host_id()
    volume.attach(hostId=lht_host_id)
    volume = wait_for_volume_healthy(client, volume_name)
    assert volume.backingImage == BACKING_IMAGE_NAME
    assert volume.size == str(BACKING_IMAGE_EXT4_SIZE)

    # Step 4
    subprocess.check_output([
        &#39;rm&#39;,
        &#39;-rf&#39;,
        os.path.join(DEFAULT_DISK_PATH, &#39;backing-images&#39;)
    ])

    # Step 5
    disk_uuid = get_disk_uuid()
    wait_for_backing_image_in_disk_fail(client, BACKING_IMAGE_NAME, disk_uuid)

    # Step 6
    wait_for_backing_image_status(client, BACKING_IMAGE_NAME,
                                  BACKING_IMAGE_STATE_READY)

    # Step 7
    volume = wait_for_volume_healthy(client, volume_name)
    assert volume.backingImage == BACKING_IMAGE_NAME
    assert volume.size == str(BACKING_IMAGE_EXT4_SIZE)</code></pre>
</details>
<div class="desc"><ol>
<li>Create a backing image.</li>
<li>Create and attach a 3-replica volume using the backing image.</li>
<li>Wait for the attachment complete.</li>
<li>Manually remove the backing image on the current node.</li>
<li>Wait for the file state in the disk/on this node become failed.</li>
<li>Wait for the file recovering automatically.</li>
<li>Validate the volume.</li>
</ol></div>
</dd>
<dt id="tests.test_backing_image.test_backing_image_basic_operation"><code class="name flex">
<span>def <span class="ident">test_backing_image_basic_operation</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest   # NOQA
@pytest.mark.backing_image  # NOQA
def test_backing_image_basic_operation(client, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        backing_image_basic_operation_test(
            client, volume_name, BACKING_IMAGE_NAME, bi_url)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_backing_image_cleanup"><code class="name flex">
<span>def <span class="ident">test_backing_image_cleanup</span></span>(<span>core_api, client)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
def test_backing_image_cleanup(core_api, client):  # NOQA
    &#34;&#34;&#34;
    1. Create multiple backing image.
    2. Create and attach multiple 3-replica volume using those backing image.
    3. Wait for the attachment complete.
    4. Delete the volumes then the backing images.
    5. Verify all backing image manager pods will be terminated when the last
       backing image is gone.
    6. Repeat step1 to step5 for multiple times. Make sure each time the test
       is using the same the backing image namings.
    &#34;&#34;&#34;
    for i in range(3):
        backing_image_cleanup(core_api, client)</code></pre>
</details>
<div class="desc"><ol>
<li>Create multiple backing image.</li>
<li>Create and attach multiple 3-replica volume using those backing image.</li>
<li>Wait for the attachment complete.</li>
<li>Delete the volumes then the backing images.</li>
<li>Verify all backing image manager pods will be terminated when the last
backing image is gone.</li>
<li>Repeat step1 to step5 for multiple times. Make sure each time the test
is using the same the backing image namings.</li>
</ol></div>
</dd>
<dt id="tests.test_backing_image.test_backing_image_content"><code class="name flex">
<span>def <span class="ident">test_backing_image_content</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest   # NOQA
@pytest.mark.backing_image  # NOQA
def test_backing_image_content(client, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        backing_image_content_test(
            client, volume_name, BACKING_IMAGE_NAME, bi_url)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_backing_image_disk_eviction"><code class="name flex">
<span>def <span class="ident">test_backing_image_disk_eviction</span></span>(<span>client)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
def test_backing_image_disk_eviction(client): # NOQA
    &#34;&#34;&#34;
    Test Disk Eviction
    - Create BackingImage with one copy
    - Evict the disk where the copy is currently on
    - The BackingImage will be evicted to other node
      because every node has only one disk
    - Check the disk is not the same as before
    &#34;&#34;&#34;
    bi_url = BACKING_IMAGE_RAW_URL
    create_backing_image_with_matching_url(
        client, BACKING_IMAGE_NAME, bi_url, minNumberOfCopies=1)

    check_backing_image_disk_map_status(client, BACKING_IMAGE_NAME, 1, &#34;ready&#34;)

    backing_image = client.by_id_backing_image(BACKING_IMAGE_NAME)
    disk_id = next(iter(backing_image.diskFileStatusMap))
    node = get_node_by_disk_id(client, disk_id)

    # Evict the disk on the node
    # and check the backing image file is evicted to other disk
    update_disks = get_update_disks(node.disks)
    for disk in update_disks.values():
        disk.allowScheduling = False
        disk.evictionRequested = True
    node = update_node_disks(client, node.name, disks=update_disks,
                             retry=True)
    check_backing_image_disk_map_status(client, BACKING_IMAGE_NAME, 1, &#34;ready&#34;)
    check_backing_image_single_copy_disk_eviction(
        client, BACKING_IMAGE_NAME, disk_id)

    # Reset the disk scheduling and eviction requested
    update_disks = get_update_disks(node.disks)
    for disk in update_disks.values():
        disk.allowScheduling = True
        disk.evictionRequested = False
    node = update_node_disks(client, node.name, disks=update_disks,
                             retry=True)

    cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"><p>Test Disk Eviction
- Create BackingImage with one copy
- Evict the disk where the copy is currently on
- The BackingImage will be evicted to other node
because every node has only one disk
- Check the disk is not the same as before</p></div>
</dd>
<dt id="tests.test_backing_image.test_backing_image_min_number_of_replicas"><code class="name flex">
<span>def <span class="ident">test_backing_image_min_number_of_replicas</span></span>(<span>client)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
def test_backing_image_min_number_of_replicas(client): # NOQA
    &#34;&#34;&#34;
    Test the backing image minNumberOfCopies

    Given
    - Create a BackingImage
    - Update the minNumberOfCopies to 2

    When
    - The BackingImage is prepared and transferred to manager

    Then
    - There will be two ready file of the BackingIamge

    Given
    - Set the setting backing-image-cleanup-wait-interval to 1 minute

    When
    - Update the minNumberOfCopies to 1
    - Wait for 1 minute

    Then
    - There will be one ready BackingImage file left.
    &#34;&#34;&#34;
    bi_url = BACKING_IMAGE_RAW_URL
    create_backing_image_with_matching_url(
        client, BACKING_IMAGE_NAME, bi_url)

    backing_image = client.by_id_backing_image(BACKING_IMAGE_NAME)
    backing_image = backing_image.updateMinNumberOfCopies(minNumberOfCopies=2)

    check_backing_image_disk_map_status(client, BACKING_IMAGE_NAME, 2, &#34;ready&#34;)

    update_setting(client, &#34;backing-image-cleanup-wait-interval&#34;, &#34;1&#34;)

    backing_image = client.by_id_backing_image(BACKING_IMAGE_NAME)
    backing_image = backing_image.updateMinNumberOfCopies(minNumberOfCopies=1)

    check_backing_image_disk_map_status(client, BACKING_IMAGE_NAME, 1, &#34;ready&#34;)
    cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"><p>Test the backing image minNumberOfCopies</p>
<p>Given
- Create a BackingImage
- Update the minNumberOfCopies to 2</p>
<p>When
- The BackingImage is prepared and transferred to manager</p>
<p>Then
- There will be two ready file of the BackingIamge</p>
<p>Given
- Set the setting backing-image-cleanup-wait-interval to 1 minute</p>
<p>When
- Update the minNumberOfCopies to 1
- Wait for 1 minute</p>
<p>Then
- There will be one ready BackingImage file left.</p></div>
</dd>
<dt id="tests.test_backing_image.test_backing_image_node_eviction"><code class="name flex">
<span>def <span class="ident">test_backing_image_node_eviction</span></span>(<span>client)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
def test_backing_image_node_eviction(client): # NOQA
    &#34;&#34;&#34;
    Test Node Eviction
    - Create BackingImage with one copy
    - Evict the node where the copy is on
    - The BackingImage will be evicted to another node
    &#34;&#34;&#34;
    bi_url = BACKING_IMAGE_RAW_URL
    create_backing_image_with_matching_url(
        client, BACKING_IMAGE_NAME, bi_url, minNumberOfCopies=1)

    check_backing_image_disk_map_status(client, BACKING_IMAGE_NAME, 1, &#34;ready&#34;)

    backing_image = client.by_id_backing_image(BACKING_IMAGE_NAME)
    disk_id = next(iter(backing_image.diskFileStatusMap))

    node = get_node_by_disk_id(client, disk_id)
    node = set_node_scheduling_eviction(
        client, node, allowScheduling=False, evictionRequested=True)

    check_backing_image_disk_map_status(client, BACKING_IMAGE_NAME, 1, &#34;ready&#34;)
    check_backing_image_single_copy_node_eviction(
        client, BACKING_IMAGE_NAME, node)

    # Set node1 back to allow scheduling
    node = set_node_scheduling_eviction(
        client, node, allowScheduling=True, evictionRequested=False)

    cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"><p>Test Node Eviction
- Create BackingImage with one copy
- Evict the node where the copy is on
- The BackingImage will be evicted to another node</p></div>
</dd>
<dt id="tests.test_backing_image.test_backing_image_selector_setting"><code class="name flex">
<span>def <span class="ident">test_backing_image_selector_setting</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
def test_backing_image_selector_setting(client, volume_name): # NOQA
    &#34;&#34;&#34;
    - Set node1 with nodeTag = [node1], diskTag = [node1]
    - Set node2 with nodeTag = [node2], diskTag = [node2]
    - Create a BackingImage with
        - minNumberOfCopies = 2
        - nodeSelector = [node1]
        - diskSelector = [node1]
    - After creation, the first BackingImage copy will be on node1, disk1
    - Wait for a while, the second one will never show up
    - Create the Volume with
        - numberOfReplicas = 1
        - nodeSelector = [node2]
        - diskSelector = [node2]
    - The volume condition Scheduled will be false
    &#34;&#34;&#34;

    tags_1 = [&#34;node1&#34;]
    tags_2 = [&#34;node2&#34;]
    nodes = client.list_node()
    node_1, node_2, node_3 = nodes
    set_tags_for_node_and_its_disks(client, node_1, tags_1)
    set_tags_for_node_and_its_disks(client, node_2, tags_2)

    backing_image_node_selector = [&#34;node1&#34;]
    backing_image_disk_selector = [&#34;node1&#34;]
    bi_url = BACKING_IMAGE_RAW_URL
    create_backing_image_with_matching_url(
        client, BACKING_IMAGE_NAME, bi_url,
        minNumberOfCopies=2,
        nodeSelector=backing_image_node_selector,
        diskSelector=backing_image_disk_selector)
    time.sleep(10)
    check_backing_image_disk_map_status(client, BACKING_IMAGE_NAME, 1, &#34;ready&#34;)

    volume_node_selector = [&#34;node2&#34;]
    volume_disk_selector = [&#34;node2&#34;]
    client.create_volume(name=volume_name, size=str(BACKING_IMAGE_EXT4_SIZE),
                         numberOfReplicas=1,
                         diskSelector=volume_disk_selector,
                         nodeSelector=volume_node_selector,
                         backingImage=BACKING_IMAGE_NAME,
                         dataEngine=DATA_ENGINE)
    vol = wait_for_volume_detached(client, volume_name)
    assert vol.diskSelector == volume_disk_selector
    assert vol.nodeSelector == volume_node_selector

    assert vol.conditions.Scheduled.status == &#34;False&#34;
    cleanup_all_volumes(client)
    cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"><ul>
<li>Set node1 with nodeTag = [node1], diskTag = [node1]</li>
<li>Set node2 with nodeTag = [node2], diskTag = [node2]</li>
<li>Create a BackingImage with<ul>
<li>minNumberOfCopies = 2</li>
<li>nodeSelector = [node1]</li>
<li>diskSelector = [node1]</li>
</ul>
</li>
<li>After creation, the first BackingImage copy will be on node1, disk1</li>
<li>Wait for a while, the second one will never show up</li>
<li>Create the Volume with<ul>
<li>numberOfReplicas = 1</li>
<li>nodeSelector = [node2]</li>
<li>diskSelector = [node2]</li>
</ul>
</li>
<li>The volume condition Scheduled will be false</li>
</ul></div>
</dd>
<dt id="tests.test_backing_image.test_backing_image_unable_eviction"><code class="name flex">
<span>def <span class="ident">test_backing_image_unable_eviction</span></span>(<span>client)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
def test_backing_image_unable_eviction(client): # NOQA
    &#34;&#34;&#34;
    - Set node1 nodeTag = [node1], diskTag = [node1]
    - Create a BackingImage with following settings to place the copy on node1
        - minNumberOfCopies = 1
        - nodeSelector = [node1]
        - diskSelector = [node1]
    - Evict node1
    - The copy would not be deleted because it is the only copy
    - The copy can&#39;t be copied to other nodes because of the selector settings.
    &#34;&#34;&#34;
    tags_1 = [&#34;node1&#34;]
    nodes = client.list_node()
    node_1, node_2, node_3 = nodes
    set_tags_for_node_and_its_disks(client, node_1, tags_1)

    backing_image_node_selector = [&#34;node1&#34;]
    backing_image_disk_selector = [&#34;node1&#34;]
    bi_url = BACKING_IMAGE_RAW_URL
    create_backing_image_with_matching_url(
        client, BACKING_IMAGE_NAME, bi_url,
        minNumberOfCopies=2,
        nodeSelector=backing_image_node_selector,
        diskSelector=backing_image_disk_selector)
    check_backing_image_disk_map_status(client, BACKING_IMAGE_NAME, 1, &#34;ready&#34;)

    backing_image = client.by_id_backing_image(BACKING_IMAGE_NAME)
    previous_disk_id = next(iter(backing_image.diskFileStatusMap))

    node_1 = set_node_scheduling_eviction(
        client, node_1, allowScheduling=False, evictionRequested=True)

    check_backing_image_eviction_failed(BACKING_IMAGE_NAME)
    check_backing_image_disk_map_status(client, BACKING_IMAGE_NAME, 1, &#34;ready&#34;)

    backing_image = client.by_id_backing_image(BACKING_IMAGE_NAME)
    current_disk_id = next(iter(backing_image.diskFileStatusMap))

    assert previous_disk_id == current_disk_id

    node_1 = set_node_scheduling_eviction(
        client, node_1, allowScheduling=True, evictionRequested=False)</code></pre>
</details>
<div class="desc"><ul>
<li>Set node1 nodeTag = [node1], diskTag = [node1]</li>
<li>Create a BackingImage with following settings to place the copy on node1<ul>
<li>minNumberOfCopies = 1</li>
<li>nodeSelector = [node1]</li>
<li>diskSelector = [node1]</li>
</ul>
</li>
<li>Evict node1</li>
<li>The copy would not be deleted because it is the only copy</li>
<li>The copy can't be copied to other nodes because of the selector settings.</li>
</ul></div>
</dd>
<dt id="tests.test_backing_image.test_backing_image_with_disk_migration"><code class="name flex">
<span>def <span class="ident">test_backing_image_with_disk_migration</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.skip(reason=&#34;TODO&#34;) # NOQA
@pytest.mark.backing_image  # NOQA
def test_backing_image_with_disk_migration():  # NOQA
    &#34;&#34;&#34;
    1. Update settings:
       1. Disable Node Soft Anti-affinity.
       2. Set Replica Replenishment Wait Interval to a relatively long value.
    2. Create a new host disk.
    3. Disable the default disk and add the extra disk with scheduling enabled
       for the current node.
    4. Create a backing image.
    5. Create and attach a 2-replica volume with the backing image set.
       Then verify:
       1. there is a replica scheduled to the new disk.
       2. there are 2 entries in the backing image disk file status map,
          and both are state `ready`.
    6. Directly mount the volume (without making filesystem) to a directory.
       Then verify the content of the backing image by checking the existence
       of the directory `&lt;Mount point&gt;/guests/`.
    7. Write random data to the mount point then verify the data.
    8. Unmount the host disk. Then verify:
       1. The replica in the host disk will be failed.
       2. The disk state in the backing image will become `unknown`.
    9. Remount the host disk to another path. Then create another Longhorn disk
       based on the migrated path (disk migration).
    10. Verify the following.
        1. The disk added in step3 (before the migration) should
           be &#34;unschedulable&#34;.
        2. The disk added in step9 (after the migration) should
           become &#34;schedulable&#34;.
        3. The failed replica will be reused. And the replica DiskID as well as
           the disk path is updated.
        4. The 2-replica volume r/w works fine.
        5. The disk state in the backing image will become `ready` again.
    11. Do cleanup.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><ol>
<li>Update settings:</li>
<li>Disable Node Soft Anti-affinity.</li>
<li>Set Replica Replenishment Wait Interval to a relatively long value.</li>
<li>Create a new host disk.</li>
<li>Disable the default disk and add the extra disk with scheduling enabled
for the current node.</li>
<li>Create a backing image.</li>
<li>Create and attach a 2-replica volume with the backing image set.
Then verify:</li>
<li>there is a replica scheduled to the new disk.</li>
<li>there are 2 entries in the backing image disk file status map,
and both are state <code>ready</code>.</li>
<li>Directly mount the volume (without making filesystem) to a directory.
Then verify the content of the backing image by checking the existence
of the directory <code>&lt;Mount point&gt;/guests/</code>.</li>
<li>Write random data to the mount point then verify the data.</li>
<li>Unmount the host disk. Then verify:</li>
<li>The replica in the host disk will be failed.</li>
<li>The disk state in the backing image will become <code>unknown</code>.</li>
<li>Remount the host disk to another path. Then create another Longhorn disk
based on the migrated path (disk migration).</li>
<li>Verify the following.<ol>
<li>The disk added in step3 (before the migration) should
be "unschedulable".</li>
<li>The disk added in step9 (after the migration) should
become "schedulable".</li>
<li>The failed replica will be reused. And the replica DiskID as well as
the disk path is updated.</li>
<li>The 2-replica volume r/w works fine.</li>
<li>The disk state in the backing image will become <code>ready</code> again.</li>
</ol>
</li>
<li>Do cleanup.</li>
</ol></div>
</dd>
<dt id="tests.test_backing_image.test_backing_image_with_wrong_md5sum"><code class="name flex">
<span>def <span class="ident">test_backing_image_with_wrong_md5sum</span></span>(<span>bi_url, client)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
@pytest.mark.parametrize(&#34;bi_url&#34;, [BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL]) # NOQA
def test_backing_image_with_wrong_md5sum(bi_url, client): # NOQA

    backing_image_wrong_checksum = \
            BACKING_IMAGE_QCOW2_CHECKSUM[1:] + BACKING_IMAGE_QCOW2_CHECKSUM[0]

    client.create_backing_image(name=BACKING_IMAGE_NAME,
                                sourceType=BACKING_IMAGE_SOURCE_TYPE_DOWNLOAD,
                                parameters={&#34;url&#34;: bi_url},
                                expectedChecksum=backing_image_wrong_checksum,
                                dataEngine=DATA_ENGINE)

    wait_for_backing_image_status(client, BACKING_IMAGE_NAME,
                                  BACKING_IMAGE_STATE_FAILED_AND_CLEANUP)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_backup_labels_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_backup_labels_with_backing_image</span></span>(<span>set_random_backupstore, client, random_labels, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest   # NOQA
@pytest.mark.backing_image  # NOQA
def test_backup_labels_with_backing_image(set_random_backupstore, client, random_labels, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        backup_labels_test(client, random_labels, volume_name,
                           str(BACKING_IMAGE_EXT4_SIZE), BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)
        backupstore_cleanup(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_backup_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_backup_with_backing_image</span></span>(<span>set_random_backupstore, client, volume_name, volume_size)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest   # NOQA
@pytest.mark.backing_image  # NOQA
@pytest.mark.parametrize(&#34;volume_size&#34;, [str(BACKING_IMAGE_EXT4_SIZE), SIZE]) # NOQA
def test_backup_with_backing_image(set_random_backupstore, client, volume_name, volume_size):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        backup_test(client, volume_name, volume_size,
                    BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)
        backupstore_cleanup(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_csi_backup_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_csi_backup_with_backing_image</span></span>(<span>set_random_backupstore, client, core_api, csi_pv, pvc, pod_make)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest  # NOQA
@pytest.mark.backing_image  # NOQA
@pytest.mark.csi  # NOQA
def test_csi_backup_with_backing_image(set_random_backupstore, client, core_api, csi_pv, pvc, pod_make):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        csi_backup_test(client, core_api, csi_pv, pvc, pod_make,
                        BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)
        backupstore_cleanup(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_csi_io_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_csi_io_with_backing_image</span></span>(<span>client, core_api, csi_pv_backingimage, pvc_backingimage, pod_make)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest   # NOQA
@pytest.mark.backing_image  # NOQA
@pytest.mark.csi  # NOQA
def test_csi_io_with_backing_image(client, core_api, csi_pv_backingimage, pvc_backingimage, pod_make):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        csi_io_test(client, core_api,
                    csi_pv_backingimage, pvc_backingimage, pod_make)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_csi_mount_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_csi_mount_with_backing_image</span></span>(<span>client, core_api, csi_pv_backingimage, pvc_backingimage, pod_make)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
@pytest.mark.csi  # NOQA
def test_csi_mount_with_backing_image(client, core_api, csi_pv_backingimage, pvc_backingimage, pod_make):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        csi_mount_test(client, core_api,
                       csi_pv_backingimage, pvc_backingimage, pod_make,
                       BACKING_IMAGE_EXT4_SIZE, BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_engine_live_upgrade_rollback_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_engine_live_upgrade_rollback_with_backing_image</span></span>(<span>client, core_api, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
def test_engine_live_upgrade_rollback_with_backing_image(client, core_api, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        engine_live_upgrade_rollback_test(client, core_api, volume_name,
                                          BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_engine_live_upgrade_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_engine_live_upgrade_with_backing_image</span></span>(<span>client, core_api, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest   # NOQA
@pytest.mark.backing_image  # NOQA
def test_engine_live_upgrade_with_backing_image(client, core_api, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        engine_live_upgrade_test(client, core_api, volume_name,
                                 BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_engine_offline_upgrade_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_engine_offline_upgrade_with_backing_image</span></span>(<span>client, core_api, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
def test_engine_offline_upgrade_with_backing_image(client, core_api, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        engine_offline_upgrade_test(client, core_api, volume_name,
                                    BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_exporting_backing_image_from_volume"><code class="name flex">
<span>def <span class="ident">test_exporting_backing_image_from_volume</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
def test_exporting_backing_image_from_volume(client, volume_name):  # NOQA
    &#34;&#34;&#34;
    1. Create and attach the 1st volume.
    2. Make a filesystem for the 1st volume.
    3. Export this volume to the 1st backing image
       via the backing image creation HTTP API. And the export type is qcow2.
    4. Create and attach the 2nd volume which uses the 1st backing image.
    5. Make sure the 2nd volume can be directly mount.
    6. Write random data to the mount point then get the checksum.
    7. Unmount and detach the 2nd volume.
    8. Export the 2nd volume as the 2nd backing image.
       Remember to set the export type to qcow2.
    9. Create and attach the 3rd volume which uses the 2nd backing image.
    10. Directly mount the 3rd volume. Then verify the data in the 3rd volume
        is the same as that of the 2nd volume.
    11. Do cleanup.
    &#34;&#34;&#34;

    # Step1, Step2
    hostId = get_self_host_id()
    volume1_name = &#34;vol1&#34;
    volume1 = create_and_check_volume(
        client, volume_name=volume1_name, size=str(1 * Gi))

    volume1 = volume1.attach(hostId=hostId)
    volume1 = wait_for_volume_healthy(client, volume1_name)

    # Step3
    backing_img1_name = &#39;bi-test1&#39;
    backing_img1 = client.create_backing_image(
            name=backing_img1_name,
            sourceType=BACKING_IMAGE_SOURCE_TYPE_FROM_VOLUME,
            parameters={&#34;export-type&#34;: &#34;qcow2&#34;, &#34;volume-name&#34;: volume1_name},
            expectedChecksum=&#34;&#34;,
            dataEngine=DATA_ENGINE)

    # Step4
    volume2_name = &#34;vol2&#34;
    volume2 = create_and_check_volume(
        client, volume_name=volume2_name, size=str(1 * Gi),
        backing_image=backing_img1[&#34;name&#34;])
    volume2 = volume2.attach(hostId=hostId)
    volume2 = wait_for_volume_healthy(client, volume2_name, 300)

    # Step5, 6
    data2 = write_volume_random_data(volume2)

    # Step7
    volume2.detach()
    volume2 = wait_for_volume_detached(client, volume2_name)

    # Step8
    backing_img2 = client.create_backing_image(
            name=&#34;bi-test2&#34;,
            sourceType=BACKING_IMAGE_SOURCE_TYPE_FROM_VOLUME,
            parameters={&#34;export-type&#34;: &#34;qcow2&#34;, &#34;volume-name&#34;: volume2_name},
            expectedChecksum=&#34;&#34;,
            dataEngine=DATA_ENGINE)

    # Step9
    volume3_name = &#34;vol3&#34;
    volume3 = create_and_check_volume(
        client, volume_name=volume3_name, size=str(1 * Gi),
        backing_image=backing_img2[&#34;name&#34;])
    volume3 = volume3.attach(hostId=hostId)
    volume3 = wait_for_volume_healthy(client, volume3_name, 450)

    # Step10
    check_volume_data(volume3, data2)</code></pre>
</details>
<div class="desc"><ol>
<li>Create and attach the 1st volume.</li>
<li>Make a filesystem for the 1st volume.</li>
<li>Export this volume to the 1st backing image
via the backing image creation HTTP API. And the export type is qcow2.</li>
<li>Create and attach the 2nd volume which uses the 1st backing image.</li>
<li>Make sure the 2nd volume can be directly mount.</li>
<li>Write random data to the mount point then get the checksum.</li>
<li>Unmount and detach the 2nd volume.</li>
<li>Export the 2nd volume as the 2nd backing image.
Remember to set the export type to qcow2.</li>
<li>Create and attach the 3rd volume which uses the 2nd backing image.</li>
<li>Directly mount the 3rd volume. Then verify the data in the 3rd volume
is the same as that of the 2nd volume.</li>
<li>Do cleanup.</li>
</ol></div>
</dd>
<dt id="tests.test_backing_image.test_ha_backup_deletion_recovery"><code class="name flex">
<span>def <span class="ident">test_ha_backup_deletion_recovery</span></span>(<span>set_random_backupstore, client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
def test_ha_backup_deletion_recovery(set_random_backupstore, client, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        ha_backup_deletion_recovery_test(client, volume_name,
                                         str(BACKING_IMAGE_EXT4_SIZE),
                                         BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)
        backupstore_cleanup(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_ha_salvage_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_ha_salvage_with_backing_image</span></span>(<span>client, core_api, disable_auto_salvage, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
def test_ha_salvage_with_backing_image(client, core_api, disable_auto_salvage, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        ha_salvage_test(client, core_api, volume_name, BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_ha_simple_recovery_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_ha_simple_recovery_with_backing_image</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest   # NOQA
@pytest.mark.backing_image  # NOQA
def test_ha_simple_recovery_with_backing_image(client, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        ha_simple_recovery_test(client, volume_name,
                                str(BACKING_IMAGE_EXT4_SIZE),
                                BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_recurring_job_labels_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_recurring_job_labels_with_backing_image</span></span>(<span>set_random_backupstore, client, random_labels, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
@pytest.mark.recurring_job  # NOQA
def test_recurring_job_labels_with_backing_image(set_random_backupstore, client, random_labels, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        recurring_job_labels_test(client, random_labels, volume_name,
                                  str(BACKING_IMAGE_EXT4_SIZE),
                                  BACKING_IMAGE_NAME)
        cleanup_all_recurring_jobs(client)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)
        backupstore_cleanup(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_snapshot_prune_and_coalesce_simultaneously_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_snapshot_prune_and_coalesce_simultaneously_with_backing_image</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest   # NOQA
@pytest.mark.backing_image  # NOQA
def test_snapshot_prune_and_coalesce_simultaneously_with_backing_image(client, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        snapshot_prune_and_coalesce_simultaneously(
            client, volume_name, BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_snapshot_prune_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_snapshot_prune_with_backing_image</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest   # NOQA
@pytest.mark.backing_image  # NOQA
def test_snapshot_prune_with_backing_image(client, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        snapshot_prune_test(client, volume_name, BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_snapshot_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_snapshot_with_backing_image</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest   # NOQA
@pytest.mark.backing_image  # NOQA
def test_snapshot_with_backing_image(client, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        snapshot_test(client, volume_name, BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_volume_basic_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_volume_basic_with_backing_image</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest   # NOQA
@pytest.mark.backing_image  # NOQA
def test_volume_basic_with_backing_image(client, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        volume_basic_test(client, volume_name, BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_volume_iscsi_basic_with_backing_image"><code class="name flex">
<span>def <span class="ident">test_volume_iscsi_basic_with_backing_image</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest   # NOQA
@pytest.mark.backing_image  # NOQA
def test_volume_iscsi_basic_with_backing_image(client, volume_name):  # NOQA
    for bi_url in (BACKING_IMAGE_QCOW2_URL, BACKING_IMAGE_RAW_URL):
        create_backing_image_with_matching_url(
            client, BACKING_IMAGE_NAME, bi_url)
        volume_iscsi_basic_test(client, volume_name, BACKING_IMAGE_NAME)
        cleanup_all_volumes(client)
        cleanup_all_backing_images(client)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_backing_image.test_volume_wait_for_backing_image_condition"><code class="name flex">
<span>def <span class="ident">test_volume_wait_for_backing_image_condition</span></span>(<span>client)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.backing_image  # NOQA
def test_volume_wait_for_backing_image_condition(client): # NOQA
    &#34;&#34;&#34;
    Test the volume condition &#34;WaitForBackingImage&#34;

    Given
    - Create a BackingImage

    When
    - Creating the Volume with the BackingImage while it is still in progress

    Then
    - The condition &#34;WaitForBackingImage&#34; of the Volume
      would be first True and then change to False when
      the BackingImage is ready and all the replicas are in running state.
    &#34;&#34;&#34;
    # Create a large volume and export as backingimage
    lht_host_id = get_self_host_id()

    volume1_name = &#34;vol1&#34;
    volume1 = create_and_check_volume(client, volume1_name,
                                      num_of_replicas=3,
                                      size=str(1 * Gi))
    volume1.attach(hostId=lht_host_id)
    volume1 = wait_for_volume_healthy(client, volume1_name)
    volume_endpoint = get_volume_endpoint(volume1)
    write_volume_dev_random_mb_data(volume_endpoint, 1, 500)
    vol1_cksum = get_device_checksum(volume_endpoint)

    backing_img_name = &#39;bi-test&#39;
    backing_img = client.create_backing_image(
            name=backing_img_name,
            sourceType=BACKING_IMAGE_SOURCE_TYPE_FROM_VOLUME,
            parameters={&#34;export-type&#34;: &#34;qcow2&#34;, &#34;volume-name&#34;: volume1_name},
            expectedChecksum=&#34;&#34;,
            dataEngine=DATA_ENGINE)

    # Create volume with that backing image
    volume2_name = &#34;vol2&#34;
    volume2 = create_and_check_volume(client, volume2_name,
                                      size=str(1 * Gi),
                                      backing_image=backing_img[&#34;name&#34;])

    volume2.attach(hostId=lht_host_id)

    if check_backing_image_disk_map_status(client,
                                           backing_img_name,
                                           1,
                                           BACKING_IMAGE_STATE_IN_PROGRESS):
        volume2 = client.by_id_volume(volume2_name)
        assert volume2.conditions.WaitForBackingImage.status == &#34;True&#34;

    # Check volume healthy, and backing image ready
    volume2 = wait_for_volume_healthy(client, volume2_name, RETRY_COUNTS_LONG)
    assert volume2.conditions.WaitForBackingImage.status == &#34;False&#34;
    check_backing_image_disk_map_status(client, backing_img_name, 3, &#34;ready&#34;)

    volume_endpoint = get_volume_endpoint(volume2)
    vol2_cksum = get_device_checksum(volume_endpoint)
    assert vol1_cksum == vol2_cksum</code></pre>
</details>
<div class="desc"><p>Test the volume condition "WaitForBackingImage"</p>
<p>Given
- Create a BackingImage</p>
<p>When
- Creating the Volume with the BackingImage while it is still in progress</p>
<p>Then
- The condition "WaitForBackingImage" of the Volume
would be first True and then change to False when
the BackingImage is ready and all the replicas are in running state.</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tests" href="index.html">tests</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tests.test_backing_image.backing_image_basic_operation_test" href="#tests.test_backing_image.backing_image_basic_operation_test">backing_image_basic_operation_test</a></code></li>
<li><code><a title="tests.test_backing_image.backing_image_cleanup" href="#tests.test_backing_image.backing_image_cleanup">backing_image_cleanup</a></code></li>
<li><code><a title="tests.test_backing_image.backing_image_content_test" href="#tests.test_backing_image.backing_image_content_test">backing_image_content_test</a></code></li>
<li><code><a title="tests.test_backing_image.test_backing_image_auto_resync" href="#tests.test_backing_image.test_backing_image_auto_resync">test_backing_image_auto_resync</a></code></li>
<li><code><a title="tests.test_backing_image.test_backing_image_basic_operation" href="#tests.test_backing_image.test_backing_image_basic_operation">test_backing_image_basic_operation</a></code></li>
<li><code><a title="tests.test_backing_image.test_backing_image_cleanup" href="#tests.test_backing_image.test_backing_image_cleanup">test_backing_image_cleanup</a></code></li>
<li><code><a title="tests.test_backing_image.test_backing_image_content" href="#tests.test_backing_image.test_backing_image_content">test_backing_image_content</a></code></li>
<li><code><a title="tests.test_backing_image.test_backing_image_disk_eviction" href="#tests.test_backing_image.test_backing_image_disk_eviction">test_backing_image_disk_eviction</a></code></li>
<li><code><a title="tests.test_backing_image.test_backing_image_min_number_of_replicas" href="#tests.test_backing_image.test_backing_image_min_number_of_replicas">test_backing_image_min_number_of_replicas</a></code></li>
<li><code><a title="tests.test_backing_image.test_backing_image_node_eviction" href="#tests.test_backing_image.test_backing_image_node_eviction">test_backing_image_node_eviction</a></code></li>
<li><code><a title="tests.test_backing_image.test_backing_image_selector_setting" href="#tests.test_backing_image.test_backing_image_selector_setting">test_backing_image_selector_setting</a></code></li>
<li><code><a title="tests.test_backing_image.test_backing_image_unable_eviction" href="#tests.test_backing_image.test_backing_image_unable_eviction">test_backing_image_unable_eviction</a></code></li>
<li><code><a title="tests.test_backing_image.test_backing_image_with_disk_migration" href="#tests.test_backing_image.test_backing_image_with_disk_migration">test_backing_image_with_disk_migration</a></code></li>
<li><code><a title="tests.test_backing_image.test_backing_image_with_wrong_md5sum" href="#tests.test_backing_image.test_backing_image_with_wrong_md5sum">test_backing_image_with_wrong_md5sum</a></code></li>
<li><code><a title="tests.test_backing_image.test_backup_labels_with_backing_image" href="#tests.test_backing_image.test_backup_labels_with_backing_image">test_backup_labels_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_backup_with_backing_image" href="#tests.test_backing_image.test_backup_with_backing_image">test_backup_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_csi_backup_with_backing_image" href="#tests.test_backing_image.test_csi_backup_with_backing_image">test_csi_backup_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_csi_io_with_backing_image" href="#tests.test_backing_image.test_csi_io_with_backing_image">test_csi_io_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_csi_mount_with_backing_image" href="#tests.test_backing_image.test_csi_mount_with_backing_image">test_csi_mount_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_engine_live_upgrade_rollback_with_backing_image" href="#tests.test_backing_image.test_engine_live_upgrade_rollback_with_backing_image">test_engine_live_upgrade_rollback_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_engine_live_upgrade_with_backing_image" href="#tests.test_backing_image.test_engine_live_upgrade_with_backing_image">test_engine_live_upgrade_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_engine_offline_upgrade_with_backing_image" href="#tests.test_backing_image.test_engine_offline_upgrade_with_backing_image">test_engine_offline_upgrade_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_exporting_backing_image_from_volume" href="#tests.test_backing_image.test_exporting_backing_image_from_volume">test_exporting_backing_image_from_volume</a></code></li>
<li><code><a title="tests.test_backing_image.test_ha_backup_deletion_recovery" href="#tests.test_backing_image.test_ha_backup_deletion_recovery">test_ha_backup_deletion_recovery</a></code></li>
<li><code><a title="tests.test_backing_image.test_ha_salvage_with_backing_image" href="#tests.test_backing_image.test_ha_salvage_with_backing_image">test_ha_salvage_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_ha_simple_recovery_with_backing_image" href="#tests.test_backing_image.test_ha_simple_recovery_with_backing_image">test_ha_simple_recovery_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_recurring_job_labels_with_backing_image" href="#tests.test_backing_image.test_recurring_job_labels_with_backing_image">test_recurring_job_labels_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_snapshot_prune_and_coalesce_simultaneously_with_backing_image" href="#tests.test_backing_image.test_snapshot_prune_and_coalesce_simultaneously_with_backing_image">test_snapshot_prune_and_coalesce_simultaneously_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_snapshot_prune_with_backing_image" href="#tests.test_backing_image.test_snapshot_prune_with_backing_image">test_snapshot_prune_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_snapshot_with_backing_image" href="#tests.test_backing_image.test_snapshot_with_backing_image">test_snapshot_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_volume_basic_with_backing_image" href="#tests.test_backing_image.test_volume_basic_with_backing_image">test_volume_basic_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_volume_iscsi_basic_with_backing_image" href="#tests.test_backing_image.test_volume_iscsi_basic_with_backing_image">test_volume_iscsi_basic_with_backing_image</a></code></li>
<li><code><a title="tests.test_backing_image.test_volume_wait_for_backing_image_condition" href="#tests.test_backing_image.test_volume_wait_for_backing_image_condition">test_volume_wait_for_backing_image_condition</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
