<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>tests.test_statefulset API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tests.test_statefulset</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tests.test_statefulset.create_and_test_backups"><code class="name flex">
<span>def <span class="ident">create_and_test_backups</span></span>(<span>api, cli, pod_info)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_and_test_backups(api, cli, pod_info):
    &#34;&#34;&#34;
    Create backups for all Pods in a StatefulSet and tests that all the backups
    have the correct attributes.

    Args:
        api: An instance of CoreV1Api.
        cli: A Longhorn client instance.
        pod_info: A List of Pods with names and volume information. This List
            can be generated using the get_statefulset_pod_info function
            located in common.py.
    &#34;&#34;&#34;
    for pod in pod_info:
        pod[&#39;data&#39;] = generate_random_data(VOLUME_RWTEST_SIZE)
        pod[&#39;backup_snapshot&#39;] = &#39;&#39;

        # Create backup.
        volume_name = pod[&#39;pv_name&#39;]
        volume = cli.by_id_volume(pod[&#39;pv_name&#39;])
        create_snapshot(cli, volume_name)
        write_pod_volume_data(api, pod[&#39;pod_name&#39;], pod[&#39;data&#39;])
        pod[&#39;backup_snapshot&#39;] = create_snapshot(cli, volume_name)
        create_snapshot(cli, volume_name)
        volume.snapshotBackup(name=pod[&#39;backup_snapshot&#39;][&#39;name&#39;])

        # Wait for backup to appear.
        found = False
        for i in range(DEFAULT_BACKUP_TIMEOUT):
            backup_volumes = cli.list_backupVolume()
            for bv in backup_volumes:
                if bv.volumeName == pod[&#39;pv_name&#39;]:
                    found = True
                    break
            if found:
                break
            time.sleep(DEFAULT_POD_INTERVAL)
        assert found

        found = False
        for i in range(DEFAULT_BACKUP_TIMEOUT):
            backups = bv.backupList().data
            for b in backups:
                if b[&#39;snapshotName&#39;] == pod[&#39;backup_snapshot&#39;][&#39;name&#39;]\
                        and b[&#39;state&#39;] == &#39;Completed&#39;:
                    found = True
                    break
            if found:
                break
            time.sleep(DEFAULT_POD_INTERVAL)
        assert found

        # Make sure backup has the correct attributes.
        new_b = bv.backupGet(name=b.name)
        assert new_b.name == b.name
        assert new_b.url == b.url
        assert new_b.snapshotName == b.snapshotName
        assert new_b.snapshotCreated == b.snapshotCreated
        assert new_b.created == b.created
        assert new_b.volumeName == b.volumeName
        assert new_b.volumeSize == b.volumeSize
        assert new_b.volumeCreated == b.volumeCreated

        # This backup has the url attribute we need to restore from backup.
        pod[&#39;backup_snapshot&#39;] = b</code></pre>
</details>
<div class="desc"><p>Create backups for all Pods in a StatefulSet and tests that all the backups
have the correct attributes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api</code></strong></dt>
<dd>An instance of CoreV1Api.</dd>
<dt><strong><code>cli</code></strong></dt>
<dd>A Longhorn client instance.</dd>
<dt><strong><code>pod_info</code></strong></dt>
<dd>A List of Pods with names and volume information. This List
can be generated using the get_statefulset_pod_info function
located in common.py.</dd>
</dl></div>
</dd>
<dt id="tests.test_statefulset.test_statefulset_backup"><code class="name flex">
<span>def <span class="ident">test_statefulset_backup</span></span>(<span>set_random_backupstore, client, core_api, storage_class, statefulset)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_statefulset_backup(set_random_backupstore, client, core_api, storage_class, statefulset):  # NOQA
    &#34;&#34;&#34;
    Test that backups on StatefulSet volumes work properly.

    1. Create a StatefulSet with VolumeClaimTemplate and Longhorn.
    2. Wait for pods to run.

    Then create backup using following steps for each pod:

    1. Create a snapshot
    2. Write some data into it
    3. Create another snapshot `backup_snapshot`
    4. Create a third snapshot
    5. Backup the snapshot `backup_snapshot`
    6. Wait for backup to show up.
        1 Verify the backup information
    &#34;&#34;&#34;

    statefulset_name = &#39;statefulset-backup-test&#39;
    update_statefulset_manifests(statefulset, storage_class, statefulset_name)

    create_storage_class(storage_class)
    create_and_wait_statefulset(statefulset)

    pod_info = get_statefulset_pod_info(core_api, statefulset)
    create_and_test_backups(core_api, client, pod_info)</code></pre>
</details>
<div class="desc"><p>Test that backups on StatefulSet volumes work properly.</p>
<ol>
<li>Create a StatefulSet with VolumeClaimTemplate and Longhorn.</li>
<li>Wait for pods to run.</li>
</ol>
<p>Then create backup using following steps for each pod:</p>
<ol>
<li>Create a snapshot</li>
<li>Write some data into it</li>
<li>Create another snapshot <code>backup_snapshot</code></li>
<li>Create a third snapshot</li>
<li>Backup the snapshot <code>backup_snapshot</code></li>
<li>Wait for backup to show up.
1 Verify the backup information</li>
</ol></div>
</dd>
<dt id="tests.test_statefulset.test_statefulset_mount"><code class="name flex">
<span>def <span class="ident">test_statefulset_mount</span></span>(<span>client, core_api, storage_class, statefulset)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_statefulset_mount(client, core_api, storage_class, statefulset):  # NOQA
    &#34;&#34;&#34;
    Tests that volumes provisioned for a StatefulSet can be properly created,
    mounted, unmounted, and deleted on the Kubernetes cluster.

    1. Create a StatefulSet using dynamic provisioned Longhorn volume.
    2. Wait for pods to become running
    3. Check volume properties are consistent with the StorageClass
    &#34;&#34;&#34;

    statefulset_name = &#39;statefulset-mount-test&#39;
    update_statefulset_manifests(statefulset, storage_class, statefulset_name)

    create_storage_class(storage_class)
    create_and_wait_statefulset(statefulset)

    pod_info = get_statefulset_pod_info(core_api, statefulset)

    volumes = client.list_volume()
    assert len(volumes) == statefulset[&#39;spec&#39;][&#39;replicas&#39;]
    for v in volumes:
        # Workaround for checking volume name since they differ per pod.
        found = False
        for pod in pod_info:
            if v.name == pod[&#39;pv_name&#39;]:
                found = True
                break
        assert found
        pod_info.remove(pod)

        assert v.size == str(DEFAULT_VOLUME_SIZE * Gi)
        assert v.numberOfReplicas == \
            int(storage_class[&#39;parameters&#39;][&#39;numberOfReplicas&#39;])
        assert v.state == &#39;attached&#39;
    # Confirm that we&#39;ve iterated through all the volumes.
    assert len(pod_info) == 0</code></pre>
</details>
<div class="desc"><p>Tests that volumes provisioned for a StatefulSet can be properly created,
mounted, unmounted, and deleted on the Kubernetes cluster.</p>
<ol>
<li>Create a StatefulSet using dynamic provisioned Longhorn volume.</li>
<li>Wait for pods to become running</li>
<li>Check volume properties are consistent with the StorageClass</li>
</ol></div>
</dd>
<dt id="tests.test_statefulset.test_statefulset_pod_deletion"><code class="name flex">
<span>def <span class="ident">test_statefulset_pod_deletion</span></span>(<span>core_api, storage_class, statefulset)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
@pytest.mark.csi  # NOQA
def test_statefulset_pod_deletion(core_api, storage_class, statefulset):  # NOQA
    &#34;&#34;&#34;
    Test that a StatefulSet can spin up a new Pod with the same data after a
    previous Pod has been deleted.

    1. Create a StatefulSet with VolumeClaimTemplate and Longhorn.
    2. Wait for pods to run.
    3. Write some data to one of the pod.
    4. Delete that pod.
    5. Wait for the StatefulSet to recreate the pod
    6. Verify the data in the pod.
    &#34;&#34;&#34;

    statefulset_name = &#39;statefulset-pod-deletion-test&#39;
    update_statefulset_manifests(statefulset, storage_class, statefulset_name)
    test_pod_name = statefulset_name + &#39;-&#39; + \
        str(randrange(statefulset[&#39;spec&#39;][&#39;replicas&#39;]))
    test_data = generate_random_data(VOLUME_RWTEST_SIZE)

    create_storage_class(storage_class)
    create_and_wait_statefulset(statefulset)

    write_pod_volume_data(core_api, test_pod_name, test_data)
    # Not using delete_and_wait_pod here because there is the small chance the
    # StatefulSet recreates the Pod quickly enough where the function won&#39;t
    # detect that the Pod was deleted, which will time out and throw an error.
    core_api.delete_namespaced_pod(name=test_pod_name, namespace=&#39;default&#39;,
                                   body=k8sclient.V1DeleteOptions())
    wait_statefulset(statefulset)
    resp = read_volume_data(core_api, test_pod_name)

    assert resp == test_data</code></pre>
</details>
<div class="desc"><p>Test that a StatefulSet can spin up a new Pod with the same data after a
previous Pod has been deleted.</p>
<ol>
<li>Create a StatefulSet with VolumeClaimTemplate and Longhorn.</li>
<li>Wait for pods to run.</li>
<li>Write some data to one of the pod.</li>
<li>Delete that pod.</li>
<li>Wait for the StatefulSet to recreate the pod</li>
<li>Verify the data in the pod.</li>
</ol></div>
</dd>
<dt id="tests.test_statefulset.test_statefulset_recurring_backup"><code class="name flex">
<span>def <span class="ident">test_statefulset_recurring_backup</span></span>(<span>set_random_backupstore, client, core_api, storage_class, statefulset)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
@pytest.mark.recurring_job  # NOQA
def test_statefulset_recurring_backup(set_random_backupstore, client, core_api, storage_class, statefulset):  # NOQA
    &#34;&#34;&#34;
    Scenario : test recurring backups on StatefulSets

    Given 1 default backup recurring jobs created.

    When create a statefulset.
    And write data to every statefulset pod.
    And wait for 5 minutes.

    Then 2 snapshots created for every statefulset pod.
    &#34;&#34;&#34;

    # backup every minute
    recurring_jobs = {
        &#34;backup&#34;: {
            &#34;task&#34;: &#34;backup&#34;,
            &#34;groups&#34;: [&#34;default&#34;],
            &#34;cron&#34;: &#34;* * * * *&#34;,
            &#34;retain&#34;: 2,
            &#34;concurrency&#34;: 2,
            &#34;labels&#34;: {},
        },
    }
    create_recurring_jobs(client, recurring_jobs)
    check_recurring_jobs(client, recurring_jobs)

    statefulset_name = &#39;statefulset-backup-test&#39;
    update_statefulset_manifests(statefulset, storage_class, statefulset_name)

    create_storage_class(storage_class)
    create_and_wait_statefulset(statefulset)

    pod_data = get_statefulset_pod_info(core_api, statefulset)
    for pod in pod_data:
        pod[&#39;data&#39;] = generate_random_data(VOLUME_RWTEST_SIZE)
        pod[&#39;backup_snapshot&#39;] = &#39;&#39;

    for pod in pod_data:
        volume = client.by_id_volume(pod[&#39;pv_name&#39;])
        write_pod_volume_data(core_api, pod[&#39;pod_name&#39;], pod[&#39;data&#39;])

    time.sleep(150)

    for pod in pod_data:
        volume = client.by_id_volume(pod[&#39;pv_name&#39;])
        write_pod_volume_data(core_api, pod[&#39;pod_name&#39;], pod[&#39;data&#39;])

    time.sleep(150)

    for pod in pod_data:
        volume = client.by_id_volume(pod[&#39;pv_name&#39;])
        snapshots = volume.snapshotList()
        count = 0
        for snapshot in snapshots:
            if snapshot.removed is False:
                count += 1

        # one backup + volume-head
        assert count == 2</code></pre>
</details>
<div class="desc"><p>Scenario : test recurring backups on StatefulSets</p>
<p>Given 1 default backup recurring jobs created.</p>
<p>When create a statefulset.
And write data to every statefulset pod.
And wait for 5 minutes.</p>
<p>Then 2 snapshots created for every statefulset pod.</p></div>
</dd>
<dt id="tests.test_statefulset.test_statefulset_restore"><code class="name flex">
<span>def <span class="ident">test_statefulset_restore</span></span>(<span>set_random_backupstore, client, core_api, storage_class, statefulset)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_statefulset_restore(set_random_backupstore, client, core_api, storage_class, statefulset):  # NOQA
    &#34;&#34;&#34;
    Test that data can be restored into volumes usable by a StatefulSet.

    1. Create a StatefulSet with VolumeClaimTemplate and Longhorn.
    2. Wait for pods to run.
    3. Create a backup for each pod.
    4. Delete the StatefulSet, including the Longhorn volumes.
    5. Create volumes and PV/PVC using previous backups from each Pod.
        1. PVs will be created using the previous names.
        2. PVCs will be created using previous name + &#34;-2&#34; due to statefulset
        has a naming policy for what should be PVC name for them.
    6. Create a new StatefulSet using the previous name + &#34;-2&#34;
    7. Wait for pods to be up.
        . Verify the pods contain the previous backed up data
    &#34;&#34;&#34;

    statefulset_name = &#39;statefulset-restore-test&#39;
    update_statefulset_manifests(statefulset, storage_class, statefulset_name)

    create_storage_class(storage_class)
    create_and_wait_statefulset(statefulset)

    pod_info = get_statefulset_pod_info(core_api, statefulset)
    create_and_test_backups(core_api, client, pod_info)

    delete_and_wait_statefulset(core_api, client, statefulset)

    csi = check_csi(core_api)

    # StatefulSet fixture already cleans these up, use the manifests instead of
    # the fixtures to avoid issues during teardown.
    pv = {
        &#39;apiVersion&#39;: &#39;v1&#39;,
        &#39;kind&#39;: &#39;PersistentVolume&#39;,
        &#39;metadata&#39;: {
            &#39;name&#39;: &#39;&#39;
        },
        &#39;spec&#39;: {
            &#39;capacity&#39;: {
                &#39;storage&#39;: size_to_string(DEFAULT_VOLUME_SIZE * Gi)
            },
            &#39;volumeMode&#39;: &#39;Filesystem&#39;,
            &#39;accessModes&#39;: [&#39;ReadWriteOnce&#39;],
            &#39;persistentVolumeReclaimPolicy&#39;: &#39;Delete&#39;,
            &#39;storageClassName&#39;: DEFAULT_STORAGECLASS_NAME
        }
    }

    pvc = {
        &#39;apiVersion&#39;: &#39;v1&#39;,
        &#39;kind&#39;: &#39;PersistentVolumeClaim&#39;,
        &#39;metadata&#39;: {
            &#39;name&#39;: &#39;&#39;
        },
        &#39;spec&#39;: {
            &#39;accessModes&#39;: [
                &#39;ReadWriteOnce&#39;
            ],
            &#39;resources&#39;: {
                &#39;requests&#39;: {
                    &#39;storage&#39;: size_to_string(DEFAULT_VOLUME_SIZE * Gi)
                }
            },
            &#39;storageClassName&#39;: DEFAULT_STORAGECLASS_NAME
        }
    }

    assert csi

    pv[&#39;spec&#39;][&#39;csi&#39;] = {
        &#39;driver&#39;: &#39;driver.longhorn.io&#39;,
        &#39;fsType&#39;: &#39;ext4&#39;,
        &#39;volumeAttributes&#39;: {
            &#39;numberOfReplicas&#39;:
                storage_class[&#39;parameters&#39;][&#39;numberOfReplicas&#39;],
            &#39;staleReplicaTimeout&#39;:
                storage_class[&#39;parameters&#39;][&#39;staleReplicaTimeout&#39;]
        },
        &#39;volumeHandle&#39;: &#39;&#39;
    }

    # Make sure that volumes still work even if the Pod and StatefulSet names
    # are different.
    for pod in pod_info:
        pod[&#39;pod_name&#39;] = pod[&#39;pod_name&#39;].replace(&#39;statefulset-restore-test&#39;,
                                                  &#39;statefulset-restore-test-2&#39;)
        pod[&#39;pvc_name&#39;] = pod[&#39;pvc_name&#39;].replace(&#39;statefulset-restore-test&#39;,
                                                  &#39;statefulset-restore-test-2&#39;)
        pv[&#39;metadata&#39;][&#39;name&#39;] = pod[&#39;pvc_name&#39;]

        client.create_volume(
            name=pod[&#39;pvc_name&#39;],
            size=size_to_string(DEFAULT_VOLUME_SIZE * Gi),
            numberOfReplicas=int(
                storage_class[&#39;parameters&#39;][&#39;numberOfReplicas&#39;]),
            fromBackup=pod[&#39;backup_snapshot&#39;][&#39;url&#39;],
            dataEngine=DATA_ENGINE)
        wait_for_volume_detached(client, pod[&#39;pvc_name&#39;])

        pv[&#39;spec&#39;][&#39;csi&#39;][&#39;volumeHandle&#39;] = pod[&#39;pvc_name&#39;]

        core_api.create_persistent_volume(pv)

        pvc[&#39;metadata&#39;][&#39;name&#39;] = pod[&#39;pvc_name&#39;]
        pvc[&#39;spec&#39;][&#39;volumeName&#39;] = pod[&#39;pvc_name&#39;]
        core_api.create_namespaced_persistent_volume_claim(
            body=pvc,
            namespace=&#39;default&#39;)

    statefulset_name = &#39;statefulset-restore-test-2&#39;
    update_statefulset_manifests(statefulset, storage_class, statefulset_name)
    create_and_wait_statefulset(statefulset)

    for pod in pod_info:
        resp = read_volume_data(core_api, pod[&#39;pod_name&#39;])
        assert resp == pod[&#39;data&#39;]</code></pre>
</details>
<div class="desc"><p>Test that data can be restored into volumes usable by a StatefulSet.</p>
<ol>
<li>Create a StatefulSet with VolumeClaimTemplate and Longhorn.</li>
<li>Wait for pods to run.</li>
<li>Create a backup for each pod.</li>
<li>Delete the StatefulSet, including the Longhorn volumes.</li>
<li>Create volumes and PV/PVC using previous backups from each Pod.<ol>
<li>PVs will be created using the previous names.</li>
<li>PVCs will be created using previous name + "-2" due to statefulset
has a naming policy for what should be PVC name for them.</li>
</ol>
</li>
<li>Create a new StatefulSet using the previous name + "-2"</li>
<li>Wait for pods to be up.
. Verify the pods contain the previous backed up data</li>
</ol></div>
</dd>
<dt id="tests.test_statefulset.test_statefulset_scaling"><code class="name flex">
<span>def <span class="ident">test_statefulset_scaling</span></span>(<span>client, core_api, storage_class, statefulset)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
@pytest.mark.coretest   # NOQA
def test_statefulset_scaling(client, core_api, storage_class, statefulset):  # NOQA
    &#34;&#34;&#34;
    Test that scaling up a StatefulSet successfully provisions new volumes.

    1. Create a StatefulSet with VolumeClaimTemplate and Longhorn.
    2. Wait for pods to run.
    3. Verify the properties of volumes.
    4. Scale the StatefulSet to 3 replicas
    5. Wait for the new pod to become ready.
    6. Verify the new volume properties.
    &#34;&#34;&#34;

    statefulset_name = &#39;statefulset-scaling-test&#39;
    update_statefulset_manifests(statefulset, storage_class, statefulset_name)

    create_storage_class(storage_class)
    create_and_wait_statefulset(statefulset)

    pod_info = get_statefulset_pod_info(core_api, statefulset)

    volumes = client.list_volume()
    assert len(volumes) == statefulset[&#39;spec&#39;][&#39;replicas&#39;]
    for v in volumes:
        found = False
        for pod in pod_info:
            if v.name == pod[&#39;pv_name&#39;]:
                found = True
                break
        assert found
        pod_info.remove(pod)

        assert v.size == str(DEFAULT_VOLUME_SIZE * Gi)
        assert v.numberOfReplicas == \
            int(storage_class[&#39;parameters&#39;][&#39;numberOfReplicas&#39;])
        assert v.state == &#39;attached&#39;
    assert len(pod_info) == 0

    statefulset[&#39;spec&#39;][&#39;replicas&#39;] = replicas = 3
    apps_api = get_apps_api_client()
    apps_api.patch_namespaced_stateful_set(
        name=statefulset_name,
        namespace=&#39;default&#39;,
        body={
            &#39;spec&#39;: {
                &#39;replicas&#39;: replicas
            }
        })
    for i in range(DEFAULT_POD_TIMEOUT):
        s_set = apps_api.read_namespaced_stateful_set(
            name=statefulset_name,
            namespace=&#39;default&#39;)
        # s_set is none if statefulset is not yet created
        if s_set is not None and s_set.status.ready_replicas == replicas:
            break
        time.sleep(DEFAULT_POD_INTERVAL)
    assert s_set.status.ready_replicas == replicas

    pod_info = get_statefulset_pod_info(core_api, statefulset)

    volumes = client.list_volume()
    assert len(volumes) == replicas
    for v in volumes:
        found = False
        for pod in pod_info:
            if v.name == pod[&#39;pv_name&#39;]:
                found = True
                break
        assert found
        pod_info.remove(pod)

        assert v.size == str(DEFAULT_VOLUME_SIZE * Gi)
        assert v.numberOfReplicas == \
            int(storage_class[&#39;parameters&#39;][&#39;numberOfReplicas&#39;])
        assert v.state == &#39;attached&#39;
    assert len(pod_info) == 0</code></pre>
</details>
<div class="desc"><p>Test that scaling up a StatefulSet successfully provisions new volumes.</p>
<ol>
<li>Create a StatefulSet with VolumeClaimTemplate and Longhorn.</li>
<li>Wait for pods to run.</li>
<li>Verify the properties of volumes.</li>
<li>Scale the StatefulSet to 3 replicas</li>
<li>Wait for the new pod to become ready.</li>
<li>Verify the new volume properties.</li>
</ol></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tests" href="index.html">tests</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tests.test_statefulset.create_and_test_backups" href="#tests.test_statefulset.create_and_test_backups">create_and_test_backups</a></code></li>
<li><code><a title="tests.test_statefulset.test_statefulset_backup" href="#tests.test_statefulset.test_statefulset_backup">test_statefulset_backup</a></code></li>
<li><code><a title="tests.test_statefulset.test_statefulset_mount" href="#tests.test_statefulset.test_statefulset_mount">test_statefulset_mount</a></code></li>
<li><code><a title="tests.test_statefulset.test_statefulset_pod_deletion" href="#tests.test_statefulset.test_statefulset_pod_deletion">test_statefulset_pod_deletion</a></code></li>
<li><code><a title="tests.test_statefulset.test_statefulset_recurring_backup" href="#tests.test_statefulset.test_statefulset_recurring_backup">test_statefulset_recurring_backup</a></code></li>
<li><code><a title="tests.test_statefulset.test_statefulset_restore" href="#tests.test_statefulset.test_statefulset_restore">test_statefulset_restore</a></code></li>
<li><code><a title="tests.test_statefulset.test_statefulset_scaling" href="#tests.test_statefulset.test_statefulset_scaling">test_statefulset_scaling</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
