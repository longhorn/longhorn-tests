<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>tests.test_ha API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tests.test_ha</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tests.test_ha.ha_backup_deletion_recovery_test"><code class="name flex">
<span>def <span class="ident">ha_backup_deletion_recovery_test</span></span>(<span>client, volume_name, size, backing_image='')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ha_backup_deletion_recovery_test(client, volume_name, size, backing_image=&#34;&#34;):  # NOQA
    client.create_volume(name=volume_name, size=size, numberOfReplicas=2,
                         backingImage=backing_image,
                         dataEngine=DATA_ENGINE)
    volume = wait_for_volume_detached(client, volume_name)

    host_id = get_self_host_id()
    volume = volume.attach(hostId=host_id)
    volume = wait_for_volume_healthy(client, volume_name)

    data = write_volume_random_data(volume)
    snap2 = create_snapshot(client, volume_name)
    create_snapshot(client, volume_name)

    volume.snapshotBackup(name=snap2.name)
    wait_for_backup_completion(client, volume_name, snap2.name)
    if backing_image != &#34;&#34;:
        wait_for_backup_volume_backing_image_synced(
            client, volume_name, backing_image
        )

    _, b = find_backup(client, volume_name, snap2.name)

    res_name = common.generate_volume_name()
    res_volume = client.create_volume(name=res_name, size=size,
                                      numberOfReplicas=2,
                                      fromBackup=b.url,
                                      dataEngine=DATA_ENGINE)
    res_volume = wait_for_volume_restoration_completed(
        client, res_name)
    res_volume = wait_for_volume_detached(client, res_name)
    res_volume = res_volume.attach(hostId=host_id)
    res_volume = wait_for_volume_healthy(client, res_name)
    check_volume_data(res_volume, data)

    snapshots = res_volume.snapshotList()
    # only the backup snapshot + volume-head
    assert len(snapshots) == 2
    backup_snapshot = &#34;&#34;
    for snap in snapshots:
        if snap.name != &#34;volume-head&#34;:
            backup_snapshot = snap.name
    assert backup_snapshot != &#34;&#34;

    create_snapshot(client, res_name)
    snapshots = res_volume.snapshotList()
    assert len(snapshots) == 3

    if DATA_ENGINE == &#34;v1&#34;:
        res_volume.snapshotDelete(name=backup_snapshot)
        res_volume.snapshotPurge()
        res_volume = wait_for_snapshot_purge(client, res_name,
                                             backup_snapshot)

        snapshots = res_volume.snapshotList()
        assert len(snapshots) == 2

    ha_rebuild_replica_test(client, res_name)

    res_volume = res_volume.detach()
    res_volume = wait_for_volume_detached(client, res_name)

    client.delete(res_volume)
    wait_for_volume_delete(client, res_name)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_ha.ha_rebuild_replica_test"><code class="name flex">
<span>def <span class="ident">ha_rebuild_replica_test</span></span>(<span>client, volname)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ha_rebuild_replica_test(client, volname):   # NOQA
    volume = client.by_id_volume(volname)
    check_volume_endpoint(volume)

    assert len(volume.replicas) == 2
    replica0 = volume.replicas[0]
    assert replica0.name != &#34;&#34;

    replica1 = volume.replicas[1]
    assert replica1.name != &#34;&#34;

    data = write_volume_random_data(volume)

    volume = volume.replicaRemove(name=replica0.name)

    # wait until we saw a replica starts rebuilding
    new_replica_found = False
    for i in range(RETRY_COUNTS):
        v = client.by_id_volume(volname)
        for r in v.replicas:
            if r.name != replica0.name and \
                    r.name != replica1.name:
                new_replica_found = True
                break
        if new_replica_found:
            break
        time.sleep(RETRY_INTERVAL)
    wait_for_rebuild_complete(client, volname)
    assert new_replica_found

    volume = wait_for_volume_healthy(client, volname)

    volume = client.by_id_volume(volname)
    assert volume.state == common.VOLUME_STATE_ATTACHED
    assert volume.robustness == common.VOLUME_ROBUSTNESS_HEALTHY
    assert len(volume.replicas) &gt;= 2

    found = False
    for replica in volume.replicas:
        if replica.name == replica1.name:
            found = True
            break
    assert found

    check_volume_data(volume, data)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_ha.ha_salvage_test"><code class="name flex">
<span>def <span class="ident">ha_salvage_test</span></span>(<span>client, core_api, volume_name, backing_image='')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ha_salvage_test(client, core_api, # NOQA
                    volume_name, backing_image=&#34;&#34;):  # NOQA

    # Setting Disable auto salvage
    # Case 1: Delete all replica processes using instance manager

    auto_salvage_setting = client.by_id_setting(SETTING_AUTO_SALVAGE)
    setting = client.update(auto_salvage_setting, value=&#34;false&#34;)
    assert setting.name == SETTING_AUTO_SALVAGE
    assert setting.value == &#34;false&#34;

    volume = create_and_check_volume(client, volume_name,
                                     num_of_replicas=2,
                                     backing_image=backing_image)

    host_id = get_self_host_id()
    volume = volume.attach(hostId=host_id)
    volume = wait_for_volume_healthy(client, volume_name)

    assert len(volume.replicas) == 2
    replica0_name = volume.replicas[0].name
    replica1_name = volume.replicas[1].name

    data = write_volume_random_data(volume)

    delete_replica_processes(client, core_api, volume_name)

    volume = wait_for_volume_faulted(client, volume_name)
    assert len(volume.replicas) == 2
    assert volume.replicas[0].failedAt != &#34;&#34;
    assert volume.replicas[1].failedAt != &#34;&#34;

    volume = wait_for_volume_detached(client, volume_name)
    volume = common.wait_for_volume_faulted(client, volume_name)

    volume.salvage(names=[replica0_name, replica1_name])
    volume = client.by_id_volume(volume_name)

    assert len(volume.replicas) == 2
    assert volume.replicas[0].failedAt == &#34;&#34;
    assert volume.replicas[1].failedAt == &#34;&#34;

    volume = wait_for_volume_healthy(client, volume_name)

    check_volume_data(volume, data)

    cleanup_volume(client, volume)

    # Setting Disable auto salvage
    # Case 2: Crash all replica processes
    auto_salvage_setting = client.by_id_setting(SETTING_AUTO_SALVAGE)
    setting = client.update(auto_salvage_setting, value=&#34;false&#34;)
    assert setting.name == SETTING_AUTO_SALVAGE
    assert setting.value == &#34;false&#34;

    volume = create_and_check_volume(client, volume_name,
                                     num_of_replicas=2,
                                     backing_image=backing_image)
    volume.attach(hostId=host_id)
    volume = wait_for_volume_healthy(client, volume_name)

    assert len(volume.replicas) == 2
    replica0_name = volume.replicas[0].name
    replica1_name = volume.replicas[1].name

    data = write_volume_random_data(volume)

    crash_replica_processes(client, core_api, volume_name)

    volume = common.wait_for_volume_faulted(client, volume_name)
    assert len(volume.replicas) == 2
    assert volume.replicas[0].failedAt != &#34;&#34;
    assert volume.replicas[1].failedAt != &#34;&#34;

    volume = common.wait_for_volume_detached(client, volume_name)
    volume = common.wait_for_volume_faulted(client, volume_name)

    volume.salvage(names=[replica0_name, replica1_name])
    volume = client.by_id_volume(volume_name)

    assert len(volume.replicas) == 2
    assert volume.replicas[0].failedAt == &#34;&#34;
    assert volume.replicas[1].failedAt == &#34;&#34;

    volume = wait_for_volume_healthy(client, volume_name)

    check_volume_data(volume, data)

    cleanup_volume(client, volume)

    # Setting: Enabled auto salvage.
    # Case 3: Revision counter disabled.

    auto_salvage_setting = client.by_id_setting(SETTING_AUTO_SALVAGE)
    setting = client.update(auto_salvage_setting, value=&#34;true&#34;)
    assert setting.name == SETTING_AUTO_SALVAGE
    assert setting.value == &#34;true&#34;

    disable_revision_counter_setting = \
        client.by_id_setting(SETTING_DISABLE_REVISION_COUNTER)
    setting = client.update(disable_revision_counter_setting, value=&#34;true&#34;)
    assert setting.name == SETTING_DISABLE_REVISION_COUNTER
    assert setting.value == &#39;{&#34;v1&#34;:&#34;true&#34;}&#39;

    volume = create_and_check_volume(client, volume_name,
                                     num_of_replicas=3,
                                     backing_image=backing_image)

    host_id = get_self_host_id()
    volume = volume.attach(hostId=host_id)
    volume = wait_for_volume_healthy(client, volume_name)

    assert len(volume.replicas) == 3
    orig_replica_names = []
    for replica in volume.replicas:
        orig_replica_names.append(replica.name)

    data = write_volume_random_data(volume)

    crash_replica_processes(client, core_api, volume_name)
    # This is a workaround, since in some case it&#39;s hard to
    # catch faulted volume status
    common.wait_for_volume_status(client, volume_name,
                                  common.VOLUME_FIELD_STATE,
                                  &#39;attaching&#39;)

    volume = wait_for_volume_healthy(client, volume_name)
    assert len(volume.replicas) == 3

    for replica in volume.replicas:
        assert replica.name in orig_replica_names

    check_volume_data(volume, data)
    cleanup_volume(client, volume)

    # Setting: Enabled auto salvage.
    # Case 4: Revision counter enabled.

    auto_salvage_setting = client.by_id_setting(SETTING_AUTO_SALVAGE)
    setting = client.update(auto_salvage_setting, value=&#34;true&#34;)
    assert setting.name == SETTING_AUTO_SALVAGE
    assert setting.value == &#34;true&#34;

    disable_revision_counter_setting = \
        client.by_id_setting(SETTING_DISABLE_REVISION_COUNTER)
    setting = client.update(disable_revision_counter_setting, value=&#34;false&#34;)
    assert setting.name == SETTING_DISABLE_REVISION_COUNTER
    assert setting.value == &#39;{&#34;v1&#34;:&#34;false&#34;}&#39;

    volume = create_and_check_volume(client, volume_name,
                                     num_of_replicas=3,
                                     backing_image=backing_image)

    host_id = get_self_host_id()
    volume = volume.attach(hostId=host_id)
    volume = wait_for_volume_healthy(client, volume_name)

    assert len(volume.replicas) == 3
    orig_replica_names = []
    for replica in volume.replicas:
        orig_replica_names.append(replica.name)

    data = write_volume_random_data(volume)

    crash_replica_processes(client, core_api, volume_name)
    # This is a workaround, since in some case it&#39;s hard to
    # catch faulted volume status
    common.wait_for_volume_status(client, volume_name,
                                  common.VOLUME_FIELD_STATE,
                                  &#39;attaching&#39;)

    volume = wait_for_volume_healthy(client, volume_name)
    assert len(volume.replicas) == 3
    assert volume.replicas[0].failedAt == &#34;&#34;
    assert volume.replicas[1].failedAt == &#34;&#34;
    assert volume.replicas[2].failedAt == &#34;&#34;

    check_volume_data(volume, data)
    cleanup_volume(client, volume)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_ha.ha_simple_recovery_test"><code class="name flex">
<span>def <span class="ident">ha_simple_recovery_test</span></span>(<span>client, volume_name, size, backing_image='')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ha_simple_recovery_test(client, volume_name, size, backing_image=&#34;&#34;):  # NOQA
    volume = create_and_check_volume(client, volume_name,
                                     num_of_replicas=2,
                                     size=size,
                                     backing_image=backing_image)

    host_id = get_self_host_id()
    volume = volume.attach(hostId=host_id)
    volume = wait_for_volume_healthy(client, volume_name)

    ha_rebuild_replica_test(client, volume_name)

    cleanup_volume(client, volume)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_ha.prepare_engine_not_fully_deployed_environment"><code class="name flex">
<span>def <span class="ident">prepare_engine_not_fully_deployed_environment</span></span>(<span>client, core_api)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_engine_not_fully_deployed_environment(client, core_api): # NOQA
    &#34;&#34;&#34;
    1. Taint node-1 with the taint: key=value:NoSchedule
    2. Delete the pod on node-1 of the engine image DaemonSet.
       Or delete the engine image DaemonSet and wait for Longhorn
       to automatically recreates it.
    3. Wait for the engine image CR state become deploying
    &#34;&#34;&#34;

    taint_node_id = taint_non_current_node(client, core_api)

    restart_and_wait_ready_engine_count(client, 2)
    default_img = common.get_default_engine_image(client)
    default_img_name = default_img.name

    # check if tainted node is marked as not deployed in `nodeDeploymentMap`.
    wait_for_tainted_node_engine_image_undeployed(client,
                                                  default_img_name,
                                                  taint_node_id)

    wait_for_deployed_engine_image_count(client, default_img_name, 2,
                                         [taint_node_id])

    return taint_node_id</code></pre>
</details>
<div class="desc"><ol>
<li>Taint node-1 with the taint: key=value:NoSchedule</li>
<li>Delete the pod on node-1 of the engine image DaemonSet.
Or delete the engine image DaemonSet and wait for Longhorn
to automatically recreates it.</li>
<li>Wait for the engine image CR state become deploying</li>
</ol></div>
</dd>
<dt id="tests.test_ha.prepare_engine_not_fully_deployed_environment_with_volumes"><code class="name flex">
<span>def <span class="ident">prepare_engine_not_fully_deployed_environment_with_volumes</span></span>(<span>client, core_api)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_engine_not_fully_deployed_environment_with_volumes(client, core_api): # NOQA
    &#34;&#34;&#34;
    1. Create 2 volumes, vol-1 and vol-2 with 3 replicas
    2. Taint node-1 with the taint: key=value:NoSchedule
    3. Attach vol-1 to node-1. Change the number of replicas of vol-1
       to 2. Delete the replica on node-1
    4. Delete the pod on node-1 of the engine image DaemonSet.
       Or delete the engine image DaemonSet and wait for Longhorn
       to automatically recreates it.
    5. Wait for the engine image CR state become deploying
    &#34;&#34;&#34;

    volume1 = create_and_check_volume(client, &#34;vol-1&#34;, size=str(3 * Gi))
    volume2 = create_and_check_volume(client, &#34;vol-2&#34;, size=str(3 * Gi))

    taint_node_id = taint_non_current_node(client, core_api)

    volume1.attach(hostId=taint_node_id)
    volume1 = wait_for_volume_healthy(client, volume1.name)
    volume1.updateReplicaCount(replicaCount=2)

    for r in volume1.replicas:
        if r.hostId == taint_node_id:
            volume1.replicaRemove(name=r.name)
            break

    restart_and_wait_ready_engine_count(client, 2)

    volume1 = client.by_id_volume(volume1.name)
    volume2 = client.by_id_volume(volume2.name)

    return volume1, volume2, taint_node_id</code></pre>
</details>
<div class="desc"><ol>
<li>Create 2 volumes, vol-1 and vol-2 with 3 replicas</li>
<li>Taint node-1 with the taint: key=value:NoSchedule</li>
<li>Attach vol-1 to node-1. Change the number of replicas of vol-1
to 2. Delete the replica on node-1</li>
<li>Delete the pod on node-1 of the engine image DaemonSet.
Or delete the engine image DaemonSet and wait for Longhorn
to automatically recreates it.</li>
<li>Wait for the engine image CR state become deploying</li>
</ol></div>
</dd>
<dt id="tests.test_ha.prepare_upgrade_image_not_fully_deployed_environment"><code class="name flex">
<span>def <span class="ident">prepare_upgrade_image_not_fully_deployed_environment</span></span>(<span>client, excluded_nodes=[])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_upgrade_image_not_fully_deployed_environment(client, excluded_nodes=[]): # NOQA
    # deploy upgrade image, wait until 2 running pods because 1 node tainted
    default_img = common.get_default_engine_image(client)
    default_img = client.by_id_engine_image(default_img.name)

    cli_v = default_img.cliAPIVersion
    cli_minv = default_img.cliAPIMinVersion
    ctl_v = default_img.controllerAPIVersion
    ctl_minv = default_img.controllerAPIMinVersion
    data_v = default_img.dataFormatVersion
    data_minv = default_img.dataFormatMinVersion

    engine_upgrade_image = common.get_upgrade_test_image(cli_v, cli_minv,
                                                         ctl_v, ctl_minv,
                                                         data_v, data_minv)

    new_img = client.create_engine_image(image=engine_upgrade_image)
    wait_for_deployed_engine_image_count(client, new_img.name, 2,
                                         excluded_nodes)
    new_img = client.by_id_engine_image(new_img.name)

    return engine_upgrade_image, new_img</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tests.test_ha.restore_with_replica_failure"><code class="name flex">
<span>def <span class="ident">restore_with_replica_failure</span></span>(<span>client,<br>core_api,<br>volume_name,<br>csi_pv,<br>pvc,<br>pod_make,<br>allow_degraded_availability,<br>disable_rebuild,<br>replica_failure_mode)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restore_with_replica_failure(client, core_api, volume_name, csi_pv, # NOQA
                                 pvc, pod_make, # NOQA
                                 allow_degraded_availability,
                                 disable_rebuild, replica_failure_mode):
    &#34;&#34;&#34;
    restore_with_replica_failure is reusable by a number of similar tests.
    In general, it attempts a volume restore, kills one of the restoring
    replicas, and verifies the restore can still complete. The manner in which
    a replica is killed and the settings enabled at the time vary with the
    parameters.
    &#34;&#34;&#34;

    backupstore_cleanup(client)

    update_setting(client, common.SETTING_DEGRADED_AVAILABILITY,
                   str(allow_degraded_availability).lower())

    data_path = &#34;/data/test&#34;
    _, _, _, md5sum = \
        prepare_pod_with_data_in_mb(client, core_api, csi_pv, pvc,
                                    pod_make,
                                    volume_name,
                                    volume_size=str(2 * Gi),
                                    data_size_in_mb=DATA_SIZE_IN_MB_4,
                                    data_path=data_path)

    volume = client.by_id_volume(volume_name)
    snap = create_snapshot(client, volume_name)
    volume.snapshotBackup(name=snap.name)
    wait_for_backup_completion(client, volume_name, snap.name, retry_count=600)
    _, b = find_backup(client, volume_name, snap.name)

    restore_volume_name = volume_name + &#34;-restore&#34;
    client.create_volume(name=restore_volume_name, size=str(2 * Gi),
                         fromBackup=b.url,
                         dataEngine=DATA_ENGINE)

    _ = wait_for_volume_restoration_start(client, restore_volume_name, b.name)
    restore_volume = client.by_id_volume(restore_volume_name)
    failed_replica = restore_volume.replicas[0]

    if disable_rebuild:
        common.update_setting(
            client,
            common.SETTING_CONCURRENT_REPLICA_REBUILD_PER_NODE_LIMIT, &#34;0&#34;)

    if replica_failure_mode == REPLICA_FAILURE_MODE_CRASH:
        crash_replica_processes(client, core_api, restore_volume_name,
                                replicas=[failed_replica],
                                wait_to_fail=False)
    if replica_failure_mode == REPLICA_FAILURE_MODE_DELETE:
        restore_volume.replicaRemove(name=failed_replica.name)

    if not disable_rebuild:
        # If disable_rebuild then we expect the volume to quickly finish
        # restoration and detach. We MIGHT be able to catch it degraded before,
        # but trying can lead to flakes. Check degraded at the end of test,
        # since no rebuilds are allowed.
        wait_for_volume_degraded(client, restore_volume_name)
        running_replica_count = 0
        for i in range(RETRY_COUNTS):
            running_replica_count = 0
            for r in restore_volume.replicas:
                if r[&#39;running&#39;] and not r[&#39;failedAt&#39;]:
                    running_replica_count += 1
            if running_replica_count == 3:
                break
            time.sleep(RETRY_INTERVAL)
        assert running_replica_count == 3

    wait_for_volume_restoration_completed(client, restore_volume_name)
    wait_for_volume_condition_restore(client, restore_volume_name,
                                      &#34;status&#34;, &#34;False&#34;)
    restore_volume = wait_for_volume_detached(client, restore_volume_name)
    assert restore_volume.ready

    if disable_rebuild and replica_failure_mode == REPLICA_FAILURE_MODE_DELETE:
        assert len(restore_volume.replicas) == 3
        for r in restore_volume.replicas:
            assert r[&#39;failedAt&#39;] == &#34;&#34;
            assert failed_replica.name != r.name

    restore_pod_name = restore_volume_name + &#34;-pod&#34;
    restore_pv_name = restore_volume_name + &#34;-pv&#34;
    restore_pvc_name = restore_volume_name + &#34;-pvc&#34;
    create_pv_for_volume(client, core_api, restore_volume, restore_pv_name)
    create_pvc_for_volume(client, core_api, restore_volume, restore_pvc_name)

    restore_pod = pod_make(name=restore_pod_name)
    restore_pod[&#39;spec&#39;][&#39;volumes&#39;] = [create_pvc_spec(restore_pvc_name)]
    create_and_wait_pod(core_api, restore_pod)

    restore_volume = client.by_id_volume(restore_volume_name)
    if disable_rebuild:
        # Restoration should be complete, but without one replica.
        assert restore_volume[VOLUME_FIELD_ROBUSTNESS] == \
            VOLUME_ROBUSTNESS_DEGRADED
    else:
        assert restore_volume[VOLUME_FIELD_ROBUSTNESS] == \
            VOLUME_ROBUSTNESS_HEALTHY

    restore_md5sum = get_pod_data_md5sum(core_api, restore_pod_name, data_path)
    assert restore_md5sum == md5sum

    # cleanup the backupstore so we don&#39;t impact other tests
    # since we crashed the replica that initiated the restore
    # it&#39;s backupstore lock will still be present, so we need to
    # wait till the lock is expired, before we can delete the backups
    backupstore_wait_for_lock_expiration()
    backupstore_cleanup(client)</code></pre>
</details>
<div class="desc"><p>restore_with_replica_failure is reusable by a number of similar tests.
In general, it attempts a volume restore, kills one of the restoring
replicas, and verifies the restore can still complete. The manner in which
a replica is killed and the settings enabled at the time vary with the
parameters.</p></div>
</dd>
<dt id="tests.test_ha.test_all_replica_restore_failure"><code class="name flex">
<span>def <span class="ident">test_all_replica_restore_failure</span></span>(<span>set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_all_replica_restore_failure(set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make):  # NOQA
    &#34;&#34;&#34;
    [HA] Test if all replica restore failure will lead to the restore volume
    becoming Faulted, and if the auto salvage feature is disabled for
    the faulted restore volume.

    1. Enable auto-salvage.
    2. Set the a random backupstore.
    3. Do cleanup for the backupstore.
    4. Create a pod with a volume and wait for pod to start.
    5. Write data to the pod volume and get the md5sum.
    6. Create a backup for the volume.
    7. Randomly delete some data blocks of the backup, which will lead to
       all replica restore failures later.
    8. Restore a volume from the backup.
    9. Wait for the volume restore in progress by checking if:
       9.1. `volume.restoreStatus` shows the related restore info.
       9.2. `volume.conditions[Restore].status == True &amp;&amp;
            volume.conditions[Restore].reason == &#34;RestoreInProgress&#34;`.
       9.3. `volume.ready == false`.
    10. Wait for the restore volume Faulted.
    11. Check if `volume.conditions[Restore].status == False &amp;&amp;
        volume.conditions[Restore].reason == &#34;RestoreFailure&#34;`.
    12. Check if `volume.ready == false`.
    13. Make sure auto-salvage is not triggered even the feature is enabled.
    14. Verify if PV/PVC cannot be created from Longhorn.
    15. Verify the faulted volume cannot be attached to a node.
    16. Verify this faulted volume can be deleted.
    &#34;&#34;&#34;
    backup_store_type = set_random_backupstore
    if backup_store_type not in [&#34;nfs&#34;, &#34;s3&#34;]:
        pytest.skip(&#34;Skip test case because the backup store type is not supported&#34;) # NOQA

    auto_salvage_setting = client.by_id_setting(SETTING_AUTO_SALVAGE)
    assert auto_salvage_setting.name == SETTING_AUTO_SALVAGE
    assert auto_salvage_setting.value == &#34;true&#34;

    backupstore_cleanup(client)

    prepare_pod_with_data_in_mb(
        client, core_api, csi_pv, pvc, pod_make, volume_name)

    snap = create_snapshot(client, volume_name)

    volume = client.by_id_volume(volume_name)
    volume.snapshotBackup(name=snap.name)
    wait_for_backup_completion(client, volume_name, snap.name)
    _, b = find_backup(client, volume_name, snap.name)

    backupstore_delete_random_backup_block(client, core_api, volume_name)

    res_name = &#34;res-&#34; + volume_name
    res_volume = client.create_volume(name=res_name,
                                      fromBackup=b.url,
                                      dataEngine=DATA_ENGINE)

    wait_for_volume_condition_restore(client, res_name,
                                      &#34;status&#34;, &#34;True&#34;)
    wait_for_volume_condition_restore(client, res_name,
                                      &#34;reason&#34;, &#34;RestoreInProgress&#34;)

    res_volume = client.by_id_volume(res_name)
    assert res_volume.ready is False

    wait_for_volume_faulted(client, res_name)
    wait_for_volume_detached(client, res_name)

    res_volume = client.by_id_volume(res_name)
    assert res_volume.conditions[&#39;Restore&#39;].status == &#34;False&#34;
    assert res_volume.conditions[&#39;Restore&#39;].reason == &#34;RestoreFailure&#34;
    assert res_volume.ready is False
    assert res_volume.state == &#34;detached&#34;
    assert hasattr(res_volume, &#39;pvCreate&#39;) is False
    assert hasattr(res_volume, &#39;pvcCreate&#39;) is False
    with pytest.raises(Exception) as e:
        res_volume.attach(hostId=get_self_host_id())
    assert &#34;unable to attach volume&#34; in str(e.value)

    client.delete(res_volume)
    wait_for_volume_delete(client, res_name)</code></pre>
</details>
<div class="desc"><p>[HA] Test if all replica restore failure will lead to the restore volume
becoming Faulted, and if the auto salvage feature is disabled for
the faulted restore volume.</p>
<ol>
<li>Enable auto-salvage.</li>
<li>Set the a random backupstore.</li>
<li>Do cleanup for the backupstore.</li>
<li>Create a pod with a volume and wait for pod to start.</li>
<li>Write data to the pod volume and get the md5sum.</li>
<li>Create a backup for the volume.</li>
<li>Randomly delete some data blocks of the backup, which will lead to
all replica restore failures later.</li>
<li>Restore a volume from the backup.</li>
<li>Wait for the volume restore in progress by checking if:
9.1. <code>volume.restoreStatus</code> shows the related restore info.
9.2. <code>volume.conditions[Restore].status == True &amp;&amp;
volume.conditions[Restore].reason == "RestoreInProgress"</code>.
9.3. <code>volume.ready == false</code>.</li>
<li>Wait for the restore volume Faulted.</li>
<li>Check if <code>volume.conditions[Restore].status == False &amp;&amp;
volume.conditions[Restore].reason == "RestoreFailure"</code>.</li>
<li>Check if <code>volume.ready == false</code>.</li>
<li>Make sure auto-salvage is not triggered even the feature is enabled.</li>
<li>Verify if PV/PVC cannot be created from Longhorn.</li>
<li>Verify the faulted volume cannot be attached to a node.</li>
<li>Verify this faulted volume can be deleted.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_auto_remount_with_subpath"><code class="name flex">
<span>def <span class="ident">test_auto_remount_with_subpath</span></span>(<span>client, core_api, storage_class, sts_name, statefulset)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_auto_remount_with_subpath(client, core_api, storage_class, sts_name, statefulset):  # NOQA
    &#34;&#34;&#34;
    Test Auto Remount With Subpath

    Context:

    Instead of manually finding and remounting all mount points of the volume,
    we delete the workload pod so that Kubernetes handles those works.
    This new implementation also solves the issue that remount doesn&#39;t
    support subpath (e.g. when pod use subpath in PVC).
    longhorn/longhorn#1719

    Steps:

    1. Deploy a storage class with parameter `numberOfReplicas: 1`
    2. Deploy a statefulset with `replicas: 1` and using the above storageclass
       Make sure the container in the pod template uses subpath, like this:
       ```yaml
       volumeMounts:
       - name: &lt;PVC-NAME&gt;
         mountPath: /data/sub
         subPath: sub
       ```
    3. exec into statefulset pod, create a file `test_data.txt`
       inside the folder `/data/sub`
    4. Delete the statefulset replica instance manager pod.
       This action simulates a network disconnection.
    5. Wait for volume `healthy`, then verify the file checksum.
    6. Repeat step #4~#5 for 3 times.
    7. Update `numberOfReplicas` to 3.
    8. Wait for replicas rebuilding finishes.
    9. Delete one of the statefulset engine instance manager pod.
    10. Wait for volume remount.
        Then verify the file checksum.
    11. Delete statefulset pod.
    12. Wait for pod recreation and volume remount.
        Then verify the file checksum.
    &#34;&#34;&#34;
    storage_class[&#39;parameters&#39;][&#39;numberOfReplicas&#39;] = &#34;1&#34;

    statefulset[&#39;spec&#39;][&#39;replicas&#39;] = 1
    statefulset[&#39;spec&#39;][&#39;selector&#39;][&#39;matchLabels&#39;][&#39;name&#39;] = sts_name
    statefulset[&#39;spec&#39;][&#39;template&#39;][&#39;metadata&#39;][&#39;labels&#39;][&#39;name&#39;] = sts_name
    statefulset[&#39;spec&#39;][&#39;template&#39;][&#39;spec&#39;][&#39;containers&#39;] = \
        [{
            &#39;image&#39;: &#39;busybox:1.34.0&#39;,
            &#39;imagePullPolicy&#39;: &#39;IfNotPresent&#39;,
            &#39;name&#39;: &#39;sleep&#39;,
            &#39;args&#39;: [
                &#39;/bin/sh&#39;,
                &#39;-c&#39;,
                &#39;while true;do date;sleep 5; done&#39;
            ],
            &#39;volumeMounts&#39;: [{
                &#39;name&#39;: &#39;pod-data&#39;,
                &#39;mountPath&#39;: &#39;/data/sub&#39;,
                &#39;subPath&#39;: &#39;sub&#39;
            }]
        }]

    data_path = &#34;/data/sub/test_data.txt&#34;
    vol_name, pod_name, md5sum = \
        common.prepare_statefulset_with_data_in_mb(
            client, core_api, statefulset, sts_name, storage_class,
            data_path=data_path)

    crash_count = 3
    for _ in range(crash_count):
        vol = client.by_id_volume(vol_name)
        rim_name = vol.replicas[0].instanceManagerName
        delete_and_wait_pod(core_api, rim_name,
                            namespace=&#39;longhorn-system&#39;,
                            wait=True)
        wait_for_volume_healthy(client, vol_name)
        common.wait_and_get_any_deployment_pod(core_api, sts_name)
        expect_md5sum = get_pod_data_md5sum(core_api, pod_name, data_path)
        assert expect_md5sum == md5sum

    vol = client.by_id_volume(vol_name)
    vol.updateReplicaCount(replicaCount=3)
    wait_for_volume_replica_count(client, vol_name, 3)
    vol = wait_for_volume_healthy(client, vol_name)

    eim_name = vol.controllers[0].instanceManagerName
    delete_and_wait_pod(core_api, eim_name,
                        namespace=&#39;longhorn-system&#39;,
                        wait=True)
    wait_for_volume_healthy(client, vol_name)
    common.wait_and_get_any_deployment_pod(core_api, sts_name)
    expect_md5sum = get_pod_data_md5sum(core_api, pod_name, data_path)
    assert expect_md5sum == md5sum

    delete_and_wait_pod(core_api, pod_name, wait=True)
    common.wait_and_get_any_deployment_pod(core_api, sts_name)
    expect_md5sum = get_pod_data_md5sum(core_api, pod_name, data_path)
    assert expect_md5sum == md5sum</code></pre>
</details>
<div class="desc"><p>Test Auto Remount With Subpath</p>
<p>Context:</p>
<p>Instead of manually finding and remounting all mount points of the volume,
we delete the workload pod so that Kubernetes handles those works.
This new implementation also solves the issue that remount doesn't
support subpath (e.g. when pod use subpath in PVC).
longhorn/longhorn#1719</p>
<p>Steps:</p>
<ol>
<li>Deploy a storage class with parameter <code>numberOfReplicas: 1</code></li>
<li>Deploy a statefulset with <code>replicas: 1</code> and using the above storageclass
Make sure the container in the pod template uses subpath, like this:
```yaml
volumeMounts:</li>
<li>name: <PVC-NAME>
mountPath: /data/sub
subPath: sub
```</li>
<li>exec into statefulset pod, create a file <code>test_data.txt</code>
inside the folder <code>/data/sub</code></li>
<li>Delete the statefulset replica instance manager pod.
This action simulates a network disconnection.</li>
<li>Wait for volume <code>healthy</code>, then verify the file checksum.</li>
<li>Repeat step #4~#5 for 3 times.</li>
<li>Update <code>numberOfReplicas</code> to 3.</li>
<li>Wait for replicas rebuilding finishes.</li>
<li>Delete one of the statefulset engine instance manager pod.</li>
<li>Wait for volume remount.
Then verify the file checksum.</li>
<li>Delete statefulset pod.</li>
<li>Wait for pod recreation and volume remount.
Then verify the file checksum.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_autosalvage_with_data_locality_enabled"><code class="name flex">
<span>def <span class="ident">test_autosalvage_with_data_locality_enabled</span></span>(<span>client, core_api, make_deployment_with_pvc, volume_name, pvc)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_autosalvage_with_data_locality_enabled(client, core_api, make_deployment_with_pvc, volume_name, pvc): # NOQA
    &#34;&#34;&#34;
    This e2e test follows the manual test steps at:
    https://github.com/longhorn/longhorn/issues/2778#issue-939331805

    Preparation:
    1. Let&#39;s call the 3 nodes: node-1, node-2, node-3

    Steps:
    1. Add the tag `node-1` to `node-1`
    2. Create a volume with 1 replica, data-locality set to best-effort,
       and tag set to `node-1`
    3. Create PV/PVC from the volume.
    4. Create a pod that uses the PVC. Set node selector for the pod so that
       it will be schedule on to `node-2`. This makes sure that there is a
       failed-to-scheduled local replica
    5. Wait for the pod to be in running state.
    6. Kill the aio instance manager on `node-1`.
    7. In a 3-min retry loop, verify that Longhorn salvage the volume
       and the workload pod is restarted. Exec into the workload pod.
       Verify that read/write to the volume is ok
    8. Exec into the longhorn manager pod on `node-2`.
       Running `ss -a -n | grep :8500 | wc -l` to find the number of socket
       connections from this manager pod to instance manager pods.
       In a 2-min loop, verify that the number of socket connection is &lt;= 20

    Cleaning up:
    1. Clean up the node tag
    &#34;&#34;&#34;

    # Step1
    nodes = client.list_node()
    assert len(nodes) == 3
    node_1, node_2, node_3 = nodes
    tags = [&#34;node-1&#34;]
    node_1 = common.set_node_tags(client, node_1, tags)

    # Step2
    client.create_volume(
        name=volume_name, size=str(1 * Gi), numberOfReplicas=1,
        nodeSelector=tags, dataLocality=&#34;best-effort&#34;,
        dataEngine=DATA_ENGINE
        )

    volume = common.wait_for_volume_detached(client, volume_name)
    assert volume.nodeSelector == tags

    # Step3
    pvc_name = volume_name + &#34;-pvc&#34;
    create_pv_for_volume(client, core_api, volume, volume_name)
    create_pvc_for_volume(client, core_api, volume, pvc_name)

    # Step4
    deployment_name = volume_name + &#34;-dep&#34;
    deployment = make_deployment_with_pvc(deployment_name, pvc_name)
    deployment[&#34;spec&#34;][&#34;template&#34;][&#34;spec&#34;][&#34;nodeSelector&#34;] \
        = {&#34;kubernetes.io/hostname&#34;: node_2.name}

    # Step5
    apps_api = get_apps_api_client()
    create_and_wait_deployment(apps_api, deployment)

    pod_names = common.get_deployment_pod_names(core_api, deployment)
    data_path = &#39;/data/test&#39;
    write_pod_volume_random_data(core_api,
                                 pod_names[0],
                                 data_path,
                                 DATA_SIZE_IN_MB_1)
    expected_test_data_checksum = get_pod_data_md5sum(core_api,
                                                      pod_names[0],
                                                      data_path)
    create_snapshot(client, volume_name)

    # Step6
    labels = f&#39;longhorn.io/node={node_1[&#34;name&#34;]}, \
               longhorn.io/instance-manager-type=aio, \
               longhorn.io/data-engine={DATA_ENGINE}&#39;

    ret = core_api.list_namespaced_pod(
            namespace=LONGHORN_NAMESPACE, label_selector=labels)
    imr_name = ret.items[0].metadata.name

    delete_and_wait_pod(core_api, pod_name=imr_name,
                        namespace=&#39;longhorn-system&#39;)

    # Step7
    target_pod = \
        core_api.read_namespaced_pod(name=pod_names[0], namespace=&#39;default&#39;)
    wait_delete_pod(core_api, target_pod.metadata.uid)
    deployment_pod = common.wait_and_get_any_deployment_pod(core_api,
                                                            deployment_name)

    test_data_checksum = get_pod_data_md5sum(core_api,
                                             deployment_pod.metadata.name,
                                             data_path)

    assert expected_test_data_checksum == test_data_checksum

    # Step8
    labels = &#34;app=longhorn-manager&#34;
    selector = &#34;spec.nodeName=={}&#34;.format(node_2[&#34;name&#34;])
    ret = core_api.list_namespaced_pod(
                namespace=LONGHORN_NAMESPACE, field_selector=selector,
                label_selector=labels)

    mgr_name = ret.items[0].metadata.name

    command = &#39;ss -a -n | grep :8500 | wc -l&#39;
    for i in range(RETRY_EXEC_COUNTS):
        socket_cnt = exec_command_in_pod(
            core_api, command, mgr_name, &#39;longhorn-system&#39;, &#39;longhorn-manager&#39;)
        assert int(socket_cnt) &lt; 20

        time.sleep(RETRY_EXEC_INTERVAL)</code></pre>
</details>
<div class="desc"><p>This e2e test follows the manual test steps at:
<a href="https://github.com/longhorn/longhorn/issues/2778#issue-939331805">https://github.com/longhorn/longhorn/issues/2778#issue-939331805</a></p>
<p>Preparation:
1. Let's call the 3 nodes: node-1, node-2, node-3</p>
<p>Steps:
1. Add the tag <code>node-1</code> to <code>node-1</code>
2. Create a volume with 1 replica, data-locality set to best-effort,
and tag set to <code>node-1</code>
3. Create PV/PVC from the volume.
4. Create a pod that uses the PVC. Set node selector for the pod so that
it will be schedule on to <code>node-2</code>. This makes sure that there is a
failed-to-scheduled local replica
5. Wait for the pod to be in running state.
6. Kill the aio instance manager on <code>node-1</code>.
7. In a 3-min retry loop, verify that Longhorn salvage the volume
and the workload pod is restarted. Exec into the workload pod.
Verify that read/write to the volume is ok
8. Exec into the longhorn manager pod on <code>node-2</code>.
Running <code>ss -a -n | grep :8500 | wc -l</code> to find the number of socket
connections from this manager pod to instance manager pods.
In a 2-min loop, verify that the number of socket connection is &lt;= 20</p>
<p>Cleaning up:
1. Clean up the node tag</p></div>
</dd>
<dt id="tests.test_ha.test_disable_replica_rebuild"><code class="name flex">
<span>def <span class="ident">test_disable_replica_rebuild</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_disable_replica_rebuild(client, volume_name):  # NOQA
    &#34;&#34;&#34;
    Test disable replica rebuild

    1. Disable node scheduling on node-2 and node-3. To make sure
    replica scheduled on node-1.
    2. Set &#39;Concurrent Replica Rebuild Per Node Limit&#39; to 0.
    3. Create a volume with 1 replica and attach it to node-1.
    4. Enable scheduling on node-2 and node-3. Set node-1 scheduling to
    &#39;Disable&#39; and &#39;Enable&#39; eviction on node-1.
    5. Wait for 30 seconds, and check no eviction happen.
    6. &#39;Enable&#39; node-1 scheduling and &#39;Disable&#39; node-1 eviction.
    7. Detach the volume and update data locality to &#39;best-effort&#39;.
    8. Attach the volume to node-2, and wait for 30 seconds, and check
    no data locality happen.
    9. Detach the volume and update data locality to &#39;disable&#39;.
    10. Attach the volume to node-2 and update the replica number to 2.
    11. Wait for 30 seconds, and no new replica scheduled and volume is
    at &#39;degraded&#39; state.
    12. Set &#39;Concurrent Replica Rebuild Per Node Limit&#39; to 5, and wait for
    replica rebuild and volume becomes &#39;healthy&#39; state with 2 replicas.
    13. Set &#39;Concurrent Replica Rebuild Per Node Limit&#39; to 0, delete one
    replica.
    14. Wait for 30 seconds, no rebuild should get triggered. The volume
    should stay in &#39;degraded&#39; state with 1 replica.
    15. Set &#39;Concurrent Replica Rebuild Per Node Limit&#39; to 5, and wait for
    replica rebuild and volume becomes &#39;healthy&#39; state with 2 replicas.
    16. Clean up the volume.
    &#34;&#34;&#34;
    # Step1
    node_1, node_2, node_3 = client.list_node()
    client.update(node_2, allowScheduling=False)
    client.update(node_3, allowScheduling=False)

    # Step2
    concurrent_replica_rebuild_per_node_limit = \
        client.by_id_setting(&#34;concurrent-replica-rebuild-per-node-limit&#34;)

    client.update(concurrent_replica_rebuild_per_node_limit, value=&#34;0&#34;)

    # Step3
    volume = client.create_volume(name=volume_name, size=SIZE,
                                  numberOfReplicas=1,
                                  dataEngine=DATA_ENGINE)
    volume = wait_for_volume_detached(client, volume_name)
    volume = volume.attach(hostId=node_1.name)
    volume = wait_for_volume_healthy(client, volume_name)

    # Step4
    client.update(node_1, allowScheduling=False)
    client.update(node_1, evictionRequested=True)
    client.update(node_2, allowScheduling=True)
    client.update(node_3, allowScheduling=True)

    # Step5
    for _ in range(RETRY_EXEC_COUNTS):
        node1_r_cnt = common.get_host_replica_count(
            client, volume_name, node_1.name, chk_running=True)

        assert node1_r_cnt == 1
        time.sleep(RETRY_INTERVAL_LONG)

    # Step6
    client.update(node_1, evictionRequested=False)
    client.update(node_1, allowScheduling=True)

    # Step7
    volume = wait_for_volume_healthy(client, volume_name)
    volume.detach(hostId=node_1.name)
    volume = wait_for_volume_detached(client, volume_name)
    volume.updateDataLocality(dataLocality=&#34;best-effort&#34;)

    # Step8
    volume = volume.attach(hostId=node_2.name)
    for _ in range(RETRY_EXEC_COUNTS):
        node2_r_cnt = common.get_host_replica_count(
            client, volume_name, node_2.name, chk_running=True)

        assert node2_r_cnt == 0
        time.sleep(RETRY_INTERVAL_LONG)

    # Step9
    volume.detach(hostId=node_2.name)
    volume = wait_for_volume_detached(client, volume_name)
    volume.updateDataLocality(dataLocality=&#34;disabled&#34;)

    # Step10
    volume = volume.attach(hostId=node_2.name)
    volume = wait_for_volume_healthy(client, volume_name)
    volume.updateReplicaCount(replicaCount=2)

    # Step11
    for _ in range(RETRY_EXEC_COUNTS):
        assert get_volume_running_replica_cnt(client, volume_name) == 1
        time.sleep(RETRY_INTERVAL_LONG)

    # Step12
    client.update(concurrent_replica_rebuild_per_node_limit, value=&#34;5&#34;)
    volume = wait_for_volume_healthy(client, volume_name)
    assert get_volume_running_replica_cnt(client, volume_name) == 2

    # Step13
    client.update(concurrent_replica_rebuild_per_node_limit, value=&#34;0&#34;)
    host_replica = get_host_replica(volume, host_id=node_1.name)
    volume.replicaRemove(name=host_replica.name)
    for _ in range(RETRY_EXEC_COUNTS):
        if get_volume_running_replica_cnt(client, volume_name) == 1:
            break
        time.sleep(RETRY_INTERVAL_LONG)

    # Step14
    for _ in range(RETRY_EXEC_COUNTS):
        assert get_volume_running_replica_cnt(client, volume_name) == 1
        time.sleep(RETRY_INTERVAL_LONG)

    # Step15
    client.update(concurrent_replica_rebuild_per_node_limit, value=&#34;5&#34;)
    volume = wait_for_volume_healthy(client, volume_name)
    assert get_volume_running_replica_cnt(client, volume_name) == 2</code></pre>
</details>
<div class="desc"><p>Test disable replica rebuild</p>
<ol>
<li>Disable node scheduling on node-2 and node-3. To make sure
replica scheduled on node-1.</li>
<li>Set 'Concurrent Replica Rebuild Per Node Limit' to 0.</li>
<li>Create a volume with 1 replica and attach it to node-1.</li>
<li>Enable scheduling on node-2 and node-3. Set node-1 scheduling to
'Disable' and 'Enable' eviction on node-1.</li>
<li>Wait for 30 seconds, and check no eviction happen.</li>
<li>'Enable' node-1 scheduling and 'Disable' node-1 eviction.</li>
<li>Detach the volume and update data locality to 'best-effort'.</li>
<li>Attach the volume to node-2, and wait for 30 seconds, and check
no data locality happen.</li>
<li>Detach the volume and update data locality to 'disable'.</li>
<li>Attach the volume to node-2 and update the replica number to 2.</li>
<li>Wait for 30 seconds, and no new replica scheduled and volume is
at 'degraded' state.</li>
<li>Set 'Concurrent Replica Rebuild Per Node Limit' to 5, and wait for
replica rebuild and volume becomes 'healthy' state with 2 replicas.</li>
<li>Set 'Concurrent Replica Rebuild Per Node Limit' to 0, delete one
replica.</li>
<li>Wait for 30 seconds, no rebuild should get triggered. The volume
should stay in 'degraded' state with 1 replica.</li>
<li>Set 'Concurrent Replica Rebuild Per Node Limit' to 5, and wait for
replica rebuild and volume becomes 'healthy' state with 2 replicas.</li>
<li>Clean up the volume.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_dr_volume_with_restore_command_error"><code class="name flex">
<span>def <span class="ident">test_dr_volume_with_restore_command_error</span></span>(<span>set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_dr_volume_with_restore_command_error(set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make):  # NOQA
    &#34;&#34;&#34;
    Test if Longhorn can capture and handle the restore command error
    rather than the error triggered the data restoring.

    1. Set a random backupstore.
    2. Create a volume, then create the corresponding PV, PVC and Pod.
    3. Write data to the pod volume and get the md5sum
       after the pod running.
    4. Create the 1st backup.
    5. Create a DR volume from the backup.
    6. Wait for the DR volume restore complete.
    7. Create a non-empty directory `volume-delta-&lt;last backup name&gt;.img`
       in one replica directory of the DR volume. This will fail the
       restore command call later.
    8. Write data to the original volume then create the 2nd backup.
    9. Wait for incremental restore complete.
       Then verify the DR volume is Degraded
       and there is one failed replica.
    10. Verify the failed replica will be reused for rebuilding
        (restore actually).
    11. Activate the DR volume and wait for it complete.
    12. Create PV/PVC/Pod for the activated volume.
    13. Validate the volume content.
    14. Verify Writing data to the activated volume is fine.
    &#34;&#34;&#34;
    update_setting(client, common.SETTING_DEGRADED_AVAILABILITY, &#34;false&#34;)

    std_volume_name = volume_name + &#34;-std&#34;
    data_path1 = &#34;/data/test1&#34;
    std_pod_name, std_pv_name, std_pvc_name, std_md5sum1 = \
        prepare_pod_with_data_in_mb(
            client, core_api, csi_pv, pvc, pod_make, std_volume_name,
            data_path=data_path1, data_size_in_mb=DATA_SIZE_IN_MB_1)

    std_volume = client.by_id_volume(std_volume_name)
    snap1 = create_snapshot(client, std_volume_name)
    std_volume.snapshotBackup(name=snap1.name)
    wait_for_backup_completion(client, std_volume_name, snap1.name)
    bv, b1 = find_backup(client, std_volume_name, snap1.name)

    dr_volume_name = volume_name + &#34;-dr&#34;
    client.create_volume(name=dr_volume_name, size=str(1 * Gi),
                         numberOfReplicas=3, fromBackup=b1.url,
                         frontend=&#34;&#34;, standby=True)
    wait_for_volume_creation(client, dr_volume_name)
    wait_for_volume_restoration_start(client, dr_volume_name, b1.name)
    wait_for_backup_restore_completed(client, dr_volume_name, b1.name)

    dr_volume = client.by_id_volume(dr_volume_name)
    # Will hack into the replica directory, create a non-empty directory
    # in the special path. (This path will be reserved for the restore.)
    # Then the following inc restore should fail.
    failed_replica = dr_volume.replicas[0]
    cmd = &#34;mkdir -p &#34; + &#34;/host&#34; + failed_replica.dataPath + &#34;/volume-delta-&#34; +\
          dr_volume.controllers[0].lastRestoredBackup + &#34;.img/random-dir&#34;
    exec_instance_manager(core_api,
                          failed_replica.instanceManagerName, cmd)

    data_path2 = &#34;/data/test2&#34;
    write_pod_volume_random_data(core_api, std_pod_name,
                                 data_path2, DATA_SIZE_IN_MB_1)
    std_md5sum2 = get_pod_data_md5sum(core_api, std_pod_name, data_path2)
    snap2 = create_snapshot(client, std_volume_name)
    std_volume.snapshotBackup(name=snap2.name)
    wait_for_backup_completion(client, std_volume_name, snap2.name)
    bv, b2 = find_backup(client, std_volume_name, snap2.name)

    # Wait for the incremental restoration triggered then complete.
    client.list_backupVolume()
    check_volume_last_backup(client, dr_volume_name, b2.name)
    wait_for_volume_restoration_start(client, dr_volume_name, b2.name)

    dr_volume = wait_for_volume_degraded(client, dr_volume_name)
    verified = False
    for r in dr_volume.replicas:
        if r.name == failed_replica.name:
            assert not r[&#39;running&#39;]
            assert r[&#39;failedAt&#39;] != &#34;&#34;
            verified = True
        else:
            assert r[&#39;running&#39;]
            assert r[&#39;failedAt&#39;] == &#34;&#34;
    assert verified

    wait_for_backup_restore_completed(client, dr_volume_name, b2.name)

    dr_volume = wait_for_volume_healthy_no_frontend(client, dr_volume_name)
    verified = False
    for r in dr_volume.replicas:
        assert r[&#39;running&#39;]
        assert r[&#39;failedAt&#39;] == &#34;&#34;
        if r.name == failed_replica.name:
            verified = True
    assert verified

    activate_standby_volume(client, dr_volume_name)
    dr_volume = wait_for_volume_detached(client, dr_volume_name)

    dr_pod_name = dr_volume_name + &#34;-pod&#34;
    dr_pv_name = dr_volume_name + &#34;-pv&#34;
    dr_pvc_name = dr_volume_name + &#34;-pvc&#34;
    dr_pod = pod_make(name=dr_pod_name)
    create_pv_for_volume(client, core_api, dr_volume, dr_pv_name)
    create_pvc_for_volume(client, core_api, dr_volume, dr_pvc_name)
    dr_pod[&#39;spec&#39;][&#39;volumes&#39;] = [create_pvc_spec(dr_pvc_name)]
    create_and_wait_pod(core_api, dr_pod)

    md5sum1 = get_pod_data_md5sum(core_api, dr_pod_name, data_path1)
    assert std_md5sum1 == md5sum1
    md5sum2 = get_pod_data_md5sum(core_api, dr_pod_name, data_path2)
    assert std_md5sum2 == md5sum2

    backupstore_cleanup(client)</code></pre>
</details>
<div class="desc"><p>Test if Longhorn can capture and handle the restore command error
rather than the error triggered the data restoring.</p>
<ol>
<li>Set a random backupstore.</li>
<li>Create a volume, then create the corresponding PV, PVC and Pod.</li>
<li>Write data to the pod volume and get the md5sum
after the pod running.</li>
<li>Create the 1st backup.</li>
<li>Create a DR volume from the backup.</li>
<li>Wait for the DR volume restore complete.</li>
<li>Create a non-empty directory <code>volume-delta-&lt;last backup name&gt;.img</code>
in one replica directory of the DR volume. This will fail the
restore command call later.</li>
<li>Write data to the original volume then create the 2nd backup.</li>
<li>Wait for incremental restore complete.
Then verify the DR volume is Degraded
and there is one failed replica.</li>
<li>Verify the failed replica will be reused for rebuilding
(restore actually).</li>
<li>Activate the DR volume and wait for it complete.</li>
<li>Create PV/PVC/Pod for the activated volume.</li>
<li>Validate the volume content.</li>
<li>Verify Writing data to the activated volume is fine.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_engine_crash_for_dr_volume"><code class="name flex">
<span>def <span class="ident">test_engine_crash_for_dr_volume</span></span>(<span>set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_engine_crash_for_dr_volume(set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make):  # NOQA
    &#34;&#34;&#34;
    [HA] Test DR volume can be recovered after
    the engine crashes unexpectedly.

    1. Setup a random backupstore.
    2. Create volume and start the pod.
    3. Write random data to the pod volume and get the md5sum.
    4. Create a backup for the volume.
    5. Create a DR volume from the backup.
    6. Wait for the DR volume init restore complete.
    7. Wait more data to the original volume and get the md5sum
    8. Create the 2nd backup for the original volume.
    9. Wait for the incremental restore triggered
       after the 2nd backup creation.
    10. Crash the DR volume engine process during the incremental restore.
    11. Wait for the DR volume detaching.
    12. Wait for the DR volume reattached.
    13. Verify the DR volume:
      13.1. `volume.ready == false`.
      13.2. `volume.conditions[Restore].status == True &amp;&amp;
            volume.conditions[Restore].reason == &#34;RestoreInProgress&#34;`.
      13.3. `volume.standby == true`
    14. Activate the DR volume and wait for detached.
    15. Create a pod for the restored volume and wait for the pod start.
    16. Check the data md5sum for the DR volume.
    &#34;&#34;&#34;
    auto_salvage_setting = client.by_id_setting(SETTING_AUTO_SALVAGE)
    assert auto_salvage_setting.name == SETTING_AUTO_SALVAGE
    assert auto_salvage_setting.value == &#34;true&#34;

    backupstore_cleanup(client)

    data_path = &#34;/data/test&#34;
    pod_name, pv_name, pvc_name, md5sum1 = \
        prepare_pod_with_data_in_mb(client, core_api, csi_pv, pvc,
                                    pod_make,
                                    volume_name,
                                    data_size_in_mb=DATA_SIZE_IN_MB_1,
                                    data_path=data_path)
    snap1 = create_snapshot(client, volume_name)
    volume = client.by_id_volume(volume_name)
    volume.snapshotBackup(name=snap1.name)
    wait_for_backup_completion(client, volume_name, snap1.name)
    bv, b1 = find_backup(client, volume_name, snap1.name)

    dr_volume_name = volume_name + &#34;-dr&#34;
    client.create_volume(name=dr_volume_name, size=str(1 * Gi),
                         numberOfReplicas=3, fromBackup=b1.url,
                         frontend=&#34;&#34;, standby=True,
                         dataEngine=DATA_ENGINE)
    wait_for_volume_creation(client, dr_volume_name)
    wait_for_volume_restoration_start(client, dr_volume_name, b1.name)
    wait_for_backup_restore_completed(client, dr_volume_name, b1.name)

    data_path2 = &#34;/data/test2&#34;
    write_pod_volume_random_data(core_api, pod_name,
                                 data_path2, DATA_SIZE_IN_MB_3)
    md5sum2 = get_pod_data_md5sum(core_api, pod_name, data_path2)
    snap2 = create_snapshot(client, volume_name)
    volume = client.by_id_volume(volume_name)
    volume.snapshotBackup(name=snap2.name)
    wait_for_backup_completion(client,
                               volume_name,
                               snap2.name,
                               retry_count=600)
    bv, b2 = find_backup(client, volume_name, snap2.name)

    # Trigger the inc restore then crash the engine process immediately.
    client.list_backupVolume()
    wait_for_volume_restoration_start(client, dr_volume_name, b2.name)
    crash_engine_process_with_sigkill(client, core_api, dr_volume_name)
    # From https://github.com/longhorn/longhorn/issues/4309#issuecomment-1197897496 # NOQA
    # The complete state transition would be like:
    # detaching -&gt; detached -&gt; attaching -&gt; attached -&gt; restore -&gt; detached .
    # Now the state change too fast, script eventually caught final detach
    # So temporarily comment out below line of code
    # wait_for_volume_detached(client, dr_volume_name)

    # Check if the DR volume is auto reattached then continue
    # restoring data.
    dr_volume = wait_for_volume_healthy_no_frontend(client, dr_volume_name)
    assert dr_volume.ready is False
    assert dr_volume.restoreRequired
    client.list_backupVolume()
    wait_for_volume_condition_restore(client, dr_volume_name,
                                      &#34;status&#34;, &#34;True&#34;)
    wait_for_volume_condition_restore(client, dr_volume_name,
                                      &#34;reason&#34;, &#34;RestoreInProgress&#34;)
    wait_for_backup_restore_completed(client, dr_volume_name, b2.name)

    activate_standby_volume(client, dr_volume_name)
    wait_for_volume_detached(client, dr_volume_name)
    wait_for_volume_condition_restore(client, dr_volume_name,
                                      &#34;status&#34;, &#34;False&#34;)
    dr_volume = wait_for_volume_detached(client, dr_volume_name)
    assert dr_volume.ready is True

    dr_pod_name = dr_volume_name + &#34;-pod&#34;
    pv_name = dr_volume_name + &#34;-pv&#34;
    pvc_name = dr_volume_name + &#34;-pvc&#34;

    create_pv_for_volume(client, core_api, dr_volume, pv_name)
    create_pvc_for_volume(client, core_api, dr_volume, pvc_name)

    dr_pod = pod_make(name=dr_pod_name)
    dr_pod[&#39;spec&#39;][&#39;volumes&#39;] = [create_pvc_spec(pvc_name)]
    create_and_wait_pod(core_api, dr_pod)

    dr_volume = client.by_id_volume(dr_volume_name)
    assert dr_volume[VOLUME_FIELD_ROBUSTNESS] == VOLUME_ROBUSTNESS_HEALTHY

    dr_md5sum1 = get_pod_data_md5sum(core_api, dr_pod_name, data_path)
    assert md5sum1 == dr_md5sum1
    dr_md5sum2 = get_pod_data_md5sum(core_api, dr_pod_name, data_path2)
    assert md5sum2 == dr_md5sum2</code></pre>
</details>
<div class="desc"><p>[HA] Test DR volume can be recovered after
the engine crashes unexpectedly.</p>
<ol>
<li>Setup a random backupstore.</li>
<li>Create volume and start the pod.</li>
<li>Write random data to the pod volume and get the md5sum.</li>
<li>Create a backup for the volume.</li>
<li>Create a DR volume from the backup.</li>
<li>Wait for the DR volume init restore complete.</li>
<li>Wait more data to the original volume and get the md5sum</li>
<li>Create the 2nd backup for the original volume.</li>
<li>Wait for the incremental restore triggered
after the 2nd backup creation.</li>
<li>Crash the DR volume engine process during the incremental restore.</li>
<li>Wait for the DR volume detaching.</li>
<li>Wait for the DR volume reattached.</li>
<li>Verify the DR volume:
13.1. <code>volume.ready == false</code>.
13.2. <code>volume.conditions[Restore].status == True &amp;&amp;
volume.conditions[Restore].reason == "RestoreInProgress"</code>.
13.3. <code>volume.standby == true</code></li>
<li>Activate the DR volume and wait for detached.</li>
<li>Create a pod for the restored volume and wait for the pod start.</li>
<li>Check the data md5sum for the DR volume.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_engine_crash_for_restore_volume"><code class="name flex">
<span>def <span class="ident">test_engine_crash_for_restore_volume</span></span>(<span>set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_engine_crash_for_restore_volume(set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make):  # NOQA
    &#34;&#34;&#34;
    [HA] Test volume can successfully retry restoring after
    the engine crashes unexpectedly.

    1. Setup a random backupstore.
    2. Create volume and start the pod.
    3. Write random data to the pod volume and get the md5sum.
    4. Create a backup for the volume.
    5. Restore a new volume from the backup.
    6. Crash the engine during the restore.
    7. Wait for the volume detaching.
    8. Wait for the volume reattached.
    9. Verify if
      9.1. `volume.ready == false`.
      9.2. `volume.conditions[Restore].status == True &amp;&amp;
            volume.conditions[Restore].reason == &#34;RestoreInProgress&#34;`.
    10. Wait for the volume restore complete and detached.
    11. Recreate a pod for the restored volume and wait for the pod start.
    12. Check the data md5sum for the restored data.
    &#34;&#34;&#34;
    auto_salvage_setting = client.by_id_setting(SETTING_AUTO_SALVAGE)
    assert auto_salvage_setting.name == SETTING_AUTO_SALVAGE
    assert auto_salvage_setting.value == &#34;true&#34;

    backupstore_cleanup(client)

    data_path = &#34;/data/test&#34;

    pod_name, pv_name, pvc_name, md5sum = \
        prepare_pod_with_data_in_mb(client, core_api, csi_pv, pvc,
                                    pod_make,
                                    volume_name,
                                    data_size_in_mb=DATA_SIZE_IN_MB_4,
                                    data_path=data_path)

    volume = client.by_id_volume(volume_name)
    snap = create_snapshot(client, volume_name)
    volume.snapshotBackup(name=snap.name)
    wait_for_backup_completion(client, volume_name, snap.name,
                               retry_count=600)
    bv, b = find_backup(client, volume_name, snap.name)

    res_name = &#34;res-&#34; + volume_name

    client.create_volume(name=res_name, fromBackup=b.url,
                         dataEngine=DATA_ENGINE)
    wait_for_volume_condition_restore(client, res_name,
                                      &#34;status&#34;, &#34;True&#34;)
    wait_for_volume_condition_restore(client, res_name,
                                      &#34;reason&#34;, &#34;RestoreInProgress&#34;)

    # Check if the restore volume is auto reattached then continue
    # restoring data.
    crash_engine_process_with_sigkill(client, core_api, res_name)
    # From https://github.com/longhorn/longhorn/issues/4309#issuecomment-1197897496 # NOQA
    # The complete state transition would be like:
    # detaching -&gt; detached -&gt; attaching -&gt; attached -&gt; restore -&gt; detached .
    # Now the state change too fast, script eventually caught final detach
    # So temporarily comment out below line of code
    # wait_for_volume_detached(client, res_name)

    res_volume = wait_for_volume_healthy_no_frontend(client, res_name)
    assert res_volume.ready is False
    assert res_volume.restoreRequired
    client.list_backupVolume()
    wait_for_volume_condition_restore(client, res_name,
                                      &#34;status&#34;, &#34;True&#34;)
    wait_for_volume_condition_restore(client, res_name,
                                      &#34;reason&#34;, &#34;RestoreInProgress&#34;)

    wait_for_volume_restoration_completed(client, res_name)
    wait_for_volume_condition_restore(client, res_name,
                                      &#34;status&#34;, &#34;False&#34;)
    res_volume = wait_for_volume_detached(client, res_name)
    assert res_volume.ready is True

    res_pod_name = res_name + &#34;-pod&#34;
    pv_name = res_name + &#34;-pv&#34;
    pvc_name = res_name + &#34;-pvc&#34;

    create_pv_for_volume(client, core_api, res_volume, pv_name)
    create_pvc_for_volume(client, core_api, res_volume, pvc_name)

    res_pod = pod_make(name=res_pod_name)
    res_pod[&#39;spec&#39;][&#39;volumes&#39;] = [create_pvc_spec(pvc_name)]
    create_and_wait_pod(core_api, res_pod)

    res_volume = client.by_id_volume(res_name)
    assert res_volume[VOLUME_FIELD_ROBUSTNESS] == VOLUME_ROBUSTNESS_HEALTHY

    res_md5sum = get_pod_data_md5sum(core_api, res_pod_name, data_path)
    assert md5sum == res_md5sum

    # cleanup the backupstore so we don&#39;t impact other tests
    # since we only crashed the engine and not the replica
    # we don&#39;t need to wait for lock expiration, since the replica
    # process will remove the lock
    backupstore_cleanup(client)</code></pre>
</details>
<div class="desc"><p>[HA] Test volume can successfully retry restoring after
the engine crashes unexpectedly.</p>
<ol>
<li>Setup a random backupstore.</li>
<li>Create volume and start the pod.</li>
<li>Write random data to the pod volume and get the md5sum.</li>
<li>Create a backup for the volume.</li>
<li>Restore a new volume from the backup.</li>
<li>Crash the engine during the restore.</li>
<li>Wait for the volume detaching.</li>
<li>Wait for the volume reattached.</li>
<li>Verify if
9.1. <code>volume.ready == false</code>.
9.2. <code>volume.conditions[Restore].status == True &amp;&amp;
volume.conditions[Restore].reason == "RestoreInProgress"</code>.</li>
<li>Wait for the volume restore complete and detached.</li>
<li>Recreate a pod for the restored volume and wait for the pod start.</li>
<li>Check the data md5sum for the restored data.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_engine_image_miss_scheduled_perform_volume_operations"><code class="name flex">
<span>def <span class="ident">test_engine_image_miss_scheduled_perform_volume_operations</span></span>(<span>core_api, client, set_random_backupstore, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_engine_image_miss_scheduled_perform_volume_operations(core_api, client, set_random_backupstore, volume_name): # NOQA
    &#34;&#34;&#34;
    Test volume operations when engine image DaemonSet is miss
    scheduled

    1. Create a volume, vol-1, of 3 replicas
    2. Taint node-1 with the taint: key=value:NoSchedule
    3. Verify that we can attach, take snapshot, take a backup,
       expand, then detach vol-1
    &#34;&#34;&#34;
    volume = create_and_check_volume(client, volume_name, size=str(3 * Gi))

    nodes = client.list_node()
    core_api.patch_node(nodes[0].id, {
        &#34;spec&#34;: {
            &#34;taints&#34;:
                [{&#34;effect&#34;: &#34;NoSchedule&#34;,
                  &#34;key&#34;: &#34;key&#34;,
                  &#34;value&#34;: &#34;value&#34;}]
        }
    })

    host_id = get_self_host_id()
    volume = volume.attach(hostId=host_id)
    volume = wait_for_volume_healthy(client, volume_name)

    snap1_data = write_volume_random_data(volume)
    snap1 = create_snapshot(client, volume_name)

    snapshots = volume.snapshotList()
    snapMap = {}
    for snap in snapshots:
        snapMap[snap.name] = snap

    assert snapMap[snap1.name].name == snap1.name
    assert snapMap[snap1.name].removed is False

    backupstore_test(client, host_id, volume_name, size=str(3 * Gi),
                     compression_method=DEFAULT_BACKUP_COMPRESSION_METHOD)

    volume = client.by_id_volume(volume_name)
    volume.attach(hostId=host_id, disableFrontend=False)
    wait_for_volume_healthy(client, volume_name)

    if DATA_ENGINE == &#34;v1&#34;:
        expand_size = str(4 * Gi)
        volume.expand(size=expand_size)
        wait_for_volume_expansion(client, volume_name)
        volume = client.by_id_volume(volume_name)
        assert volume.size == expand_size
        check_block_device_size(volume, int(expand_size))
    volume = client.by_id_volume(volume_name)
    check_volume_data(volume, snap1_data, False)</code></pre>
</details>
<div class="desc"><p>Test volume operations when engine image DaemonSet is miss
scheduled</p>
<ol>
<li>Create a volume, vol-1, of 3 replicas</li>
<li>Taint node-1 with the taint: key=value:NoSchedule</li>
<li>Verify that we can attach, take snapshot, take a backup,
expand, then detach vol-1</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_engine_image_not_fully_deployed_perform_auto_upgrade_engine"><code class="name flex">
<span>def <span class="ident">test_engine_image_not_fully_deployed_perform_auto_upgrade_engine</span></span>(<span>client, core_api)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_engine_image_not_fully_deployed_perform_auto_upgrade_engine(client, core_api): # NOQA
    &#34;&#34;&#34;
    Test auto upgrade engine feature when engine image DaemonSet is
    not fully deployed

    Prerequisite:
    Prepare system for the test by calling the method
    prepare_engine_not_fully_deployed_evnironment to have
    tainted node and not fully deployed engine.

    1. Create 2 volumes vol-1 and vol-2 with 2 replicas
    2. Attach both volumes to make sure they are healthy and have 2 replicas
    4. Detach both volumes
    5. Deploy a new engine image, new-ei
    6. Upgrade vol-1 and vol-2 to the new-ei
    7. Attach vol-2 to current-node
    8. Set `Concurrent Automatic Engine Upgrade Per Node Limit` setting to 3
    9. In a 2-min retry, verify that Longhorn upgrades the engine image of
       vol-1 and vol-2.
    &#34;&#34;&#34;
    tainted_node_id = \
        prepare_engine_not_fully_deployed_environment(client, core_api)

    volume1 = create_and_check_volume(client, &#34;vol-1&#34;,
                                      num_of_replicas=2,
                                      size=str(3 * Gi))

    volume2 = create_and_check_volume(client, &#34;vol-2&#34;,
                                      num_of_replicas=2,
                                      size=str(3 * Gi))

    volume1.attach(hostId=get_self_host_id())
    volume2.attach(hostId=get_self_host_id())
    volume1 = wait_for_volume_healthy(client, volume1.name)
    volume2 = wait_for_volume_healthy(client, volume2.name)
    wait_for_replica_count(client, volume1.name, 2)
    wait_for_replica_count(client, volume2.name, 2)

    volume1.detach()
    volume2.detach()
    volume1 = wait_for_volume_detached(client, volume1.name)
    volume2 = wait_for_volume_detached(client, volume2.name)

    default_img = common.get_default_engine_image(client)
    # engine reference =
    # (1 volume + 1 engine + number of replicas) * volume count
    wait_for_engine_image_ref_count(client, default_img.name, 8)

    engine_upgrade_image, new_img = \
        prepare_upgrade_image_not_fully_deployed_environment(client,
                                                             [tainted_node_id])

    volume1.engineUpgrade(image=engine_upgrade_image)
    volume2.engineUpgrade(image=engine_upgrade_image)
    volume1 = wait_for_volume_current_image(client, volume1.name,
                                            engine_upgrade_image)
    volume2 = wait_for_volume_current_image(client, volume2.name,
                                            engine_upgrade_image)

    default_img = common.get_default_engine_image(client)
    wait_for_engine_image_ref_count(client, default_img.name, 0)

    volume2.attach(hostId=get_self_host_id())
    volume2 = wait_for_volume_healthy(client, volume2.name)

    update_setting(client,
                   SETTING_CONCURRENT_AUTO_ENGINE_UPGRADE_NODE_LIMIT,
                   &#34;3&#34;)

    wait_for_engine_image_ref_count(client, new_img.name, 0)
    wait_for_volume_healthy(client, volume2.name)

    volume1 = client.by_id_volume(volume1.name)
    volume2 = client.by_id_volume(volume2.name)
    assert volume1.image == default_img.image
    assert volume2.image == default_img.image</code></pre>
</details>
<div class="desc"><p>Test auto upgrade engine feature when engine image DaemonSet is
not fully deployed</p>
<p>Prerequisite:
Prepare system for the test by calling the method
prepare_engine_not_fully_deployed_evnironment to have
tainted node and not fully deployed engine.</p>
<ol>
<li>Create 2 volumes vol-1 and vol-2 with 2 replicas</li>
<li>Attach both volumes to make sure they are healthy and have 2 replicas</li>
<li>Detach both volumes</li>
<li>Deploy a new engine image, new-ei</li>
<li>Upgrade vol-1 and vol-2 to the new-ei</li>
<li>Attach vol-2 to current-node</li>
<li>Set <code>Concurrent Automatic Engine Upgrade Per Node Limit</code> setting to 3</li>
<li>In a 2-min retry, verify that Longhorn upgrades the engine image of
vol-1 and vol-2.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_engine_image_not_fully_deployed_perform_dr_restoring_expanding_volume"><code class="name flex">
<span>def <span class="ident">test_engine_image_not_fully_deployed_perform_dr_restoring_expanding_volume</span></span>(<span>client, core_api, set_random_backupstore)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_engine_image_not_fully_deployed_perform_dr_restoring_expanding_volume(client, core_api, set_random_backupstore): # NOQA
    &#34;&#34;&#34;
    Test DR, restoring, expanding volumes when engine image DaemonSet
    is not fully deployed

    Prerequisite:
    Prepare system for the test by calling the method
    prepare_engine_not_fully_deployed_evnironment to have
    tainted node and not fully deployed engine.

    1. Create volume vol-1 with 2 replicas
    2. Attach vol-1 to node-2, write data and create backup
    3. Create a DR volume (vol-dr) of 2 replicas.
    4. Verify that 2 replicas are on node-2 and node-3 and the DR volume
       is attached to either node-2 or node-3.
       Let&#39;s say it is attached to node-x
    5. Taint node-x with the taint `key=value:NoSchedule`
    6. Delete the pod of engine image DeamonSet on node-x. Now, the engine
       image is missing on node-1 and node-x
    7. Verify that vol-dr is auto-attached node-y.
    8. Restore a volume from backupstore with name vol-rs and replica count
       is 1
    9. Verify that replica is on node-y and the volume successfully restored.
    10. Wait for vol-rs to finish restoring
    11. Expand vol-rs.
    12. Verify that the expansion is ok
    13. Set `Replica Replenishment Wait Interval` setting to 600
    14. Crash the replica of vol-1 on node-x. Wait for the replica to fail
    15. In a 2-min retry verify that Longhorn doesn&#39;t create new replica
       for vol-1 and doesn&#39;t reuse the failed replica on node-x
    &#34;&#34;&#34;
    update_setting(client, common.SETTING_DEGRADED_AVAILABILITY, &#34;false&#34;)

    tainted_node_id = \
        prepare_engine_not_fully_deployed_environment(client, core_api)

    # step 1
    volume1 = create_and_check_volume(client, &#34;vol-1&#34;,
                                      num_of_replicas=2,
                                      size=str(1 * Gi))

    # node1: tainted node, node2: self host node, node3: the last one
    nodes = client.list_node()
    for node in nodes:
        if node.id == get_self_host_id():
            node2 = node
        elif node.id != tainted_node_id and node.id != get_self_host_id:
            node3 = node

    # step 2
    volume1 = volume1.attach(hostId=node2.id)
    volume1 = wait_for_volume_healthy(client, volume1.name)

    volume_endpoint = get_volume_endpoint(volume1)
    snap1_offset = 1
    snap_data_size_in_mb = 4
    write_volume_dev_random_mb_data(volume_endpoint,
                                    snap1_offset, snap_data_size_in_mb)

    snap = create_snapshot(client, volume1.name)
    volume1.snapshotBackup(name=snap.name)
    wait_for_backup_completion(client,
                               volume1.name,
                               snap.name,
                               retry_count=600)
    bv, b1 = find_backup(client, volume1.name, snap.name)

    dr_volume_name = volume1.name + &#34;-dr&#34;
    client.create_volume(name=dr_volume_name, size=str(1 * Gi),
                         numberOfReplicas=2, fromBackup=b1.url,
                         frontend=&#34;&#34;, standby=True)
    wait_for_volume_creation(client, dr_volume_name)
    wait_for_backup_restore_completed(client, dr_volume_name, b1.name)
    dr_volume = client.by_id_volume(dr_volume_name)

    # step 4
    on_node2 = False
    on_node3 = False
    for replica in dr_volume.replicas:
        if replica.hostId == node2.id:
            on_node2 = True
        if replica.hostId == node3.id:
            on_node3 = True

    assert on_node2
    assert on_node3

    # step 5
    node_x = dr_volume.controllers[0].hostId
    core_api.patch_node(
        node_x, {
            &#34;spec&#34;: {
                &#34;taints&#34;:
                    [{&#34;effect&#34;: &#34;NoSchedule&#34;,
                        &#34;key&#34;: &#34;key&#34;,
                        &#34;value&#34;: &#34;value&#34;}]
            }
        })

    # step 6
    restart_and_wait_ready_engine_count(client, 1)

    # step 7
    dr_volume = wait_for_volume_degraded(client, dr_volume.name)
    assert dr_volume.controllers[0].hostId != tainted_node_id
    assert dr_volume.controllers[0].hostId != node_x

    node_running_latest_enging = dr_volume.controllers[0].hostId

    # step 8, 9 10
    res_vol_name = &#34;vol-rs&#34;

    client.create_volume(name=res_vol_name, numberOfReplicas=1,
                         fromBackup=b1.url)
    wait_for_volume_condition_restore(client, res_vol_name,
                                      &#34;status&#34;, &#34;True&#34;)
    wait_for_volume_condition_restore(client, res_vol_name,
                                      &#34;reason&#34;, &#34;RestoreInProgress&#34;)

    res_volume = wait_for_volume_detached(client, res_vol_name)
    res_volume = client.by_id_volume(res_vol_name)

    assert res_volume.ready is True
    assert len(res_volume.replicas) == 1
    assert res_volume.replicas[0].hostId == node_running_latest_enging

    # step 11, 12
    expand_size = str(2 * Gi)
    res_volume.expand(size=expand_size)
    wait_for_volume_expansion(client, res_volume.name)
    res_volume = wait_for_volume_detached(client, res_volume.name)
    res_volume.attach(hostId=node_running_latest_enging, disableFrontend=False)
    res_volume = wait_for_volume_healthy(client, res_volume.name)
    assert res_volume.size == expand_size

    # step 13
    replenish_wait_setting = \
        client.by_id_setting(SETTING_REPLICA_REPLENISHMENT_WAIT_INTERVAL)
    client.update(replenish_wait_setting, value=&#34;600&#34;)

    # step 14
    volume1 = client.by_id_volume(volume1.name)
    for replica in volume1.replicas:
        if replica.hostId == node_x:
            crash_replica_processes(client, core_api, volume1.name,
                                    replicas=[replica],
                                    wait_to_fail=True)

    # step 15
    for i in range(RETRY_COUNTS_SHORT * 2):
        volume1 = client.by_id_volume(volume1.name)
        assert len(volume1.replicas) == 2, f&#34;volume1 = {volume1}&#34;
        for replica in volume1.replicas:
            if replica.hostId == node_x:
                assert replica.running is False
            else:
                assert replica.running is True

        time.sleep(RETRY_INTERVAL_LONG)</code></pre>
</details>
<div class="desc"><p>Test DR, restoring, expanding volumes when engine image DaemonSet
is not fully deployed</p>
<p>Prerequisite:
Prepare system for the test by calling the method
prepare_engine_not_fully_deployed_evnironment to have
tainted node and not fully deployed engine.</p>
<ol>
<li>Create volume vol-1 with 2 replicas</li>
<li>Attach vol-1 to node-2, write data and create backup</li>
<li>Create a DR volume (vol-dr) of 2 replicas.</li>
<li>Verify that 2 replicas are on node-2 and node-3 and the DR volume
is attached to either node-2 or node-3.
Let's say it is attached to node-x</li>
<li>Taint node-x with the taint <code>key=value:NoSchedule</code></li>
<li>Delete the pod of engine image DeamonSet on node-x. Now, the engine
image is missing on node-1 and node-x</li>
<li>Verify that vol-dr is auto-attached node-y.</li>
<li>Restore a volume from backupstore with name vol-rs and replica count
is 1</li>
<li>Verify that replica is on node-y and the volume successfully restored.</li>
<li>Wait for vol-rs to finish restoring</li>
<li>Expand vol-rs.</li>
<li>Verify that the expansion is ok</li>
<li>Set <code>Replica Replenishment Wait Interval</code> setting to 600</li>
<li>Crash the replica of vol-1 on node-x. Wait for the replica to fail</li>
<li>In a 2-min retry verify that Longhorn doesn't create new replica
for vol-1 and doesn't reuse the failed replica on node-x</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_engine_image_not_fully_deployed_perform_engine_upgrade"><code class="name flex">
<span>def <span class="ident">test_engine_image_not_fully_deployed_perform_engine_upgrade</span></span>(<span>client, core_api)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_engine_image_not_fully_deployed_perform_engine_upgrade(client, core_api): # NOQA
    &#34;&#34;&#34;
    Test engine upgrade when engine image DaemonSet is not fully
    deployed

    Prerequisite:
    Prepare system for the test by calling the method
    prepare_engine_not_fully_deployed_evnironment_with_volumes to have
    2 volumes, tainted node and not fully deployed engine.

    1. Deploy a new engine image, new-ei
    2. Detach vol-1, verify that you can upgrade vol-1 to new-ei
    3. Detach then attach vol-1 to node-2
    4. Verify that you can live upgrade vol-1 to back to default engine image
    5. Try to upgrade vol-2 to new-ei
    6. Verify that the engineUpgrade API call returns error
    &#34;&#34;&#34;
    volume1, volume2, tainted_node_id = \
        prepare_engine_not_fully_deployed_environment_with_volumes(client,
                                                                   core_api)

    volume1.detach()
    volume1 = wait_for_volume_detached(client, volume1.name)

    engine_upgrade_image, new_img = \
        prepare_upgrade_image_not_fully_deployed_environment(client,
                                                             [tainted_node_id])

    # expected refCount: 1 for volume + 1 for engine and number of replicas(2)
    expect_ref_count = 4
    new_img_name = new_img.name
    original_engine_image = volume1.image
    volume1.engineUpgrade(image=engine_upgrade_image)
    volume1 = wait_for_volume_current_image(client, volume1.name,
                                            engine_upgrade_image)
    new_img = wait_for_engine_image_ref_count(client,
                                              new_img_name,
                                              expect_ref_count)

    host_id = get_self_host_id()
    volume1.attach(hostId=host_id)
    volume1 = wait_for_volume_healthy(client, volume1.name)

    volume1.engineUpgrade(image=original_engine_image)
    volume1 = wait_for_volume_current_image(client, volume1.name,
                                            original_engine_image)

    new_img = wait_for_engine_image_ref_count(client,
                                              new_img_name,
                                              0)

    can_not_upgrade = False
    volume2 = client.by_id_volume(volume2.name)
    try:
        volume2.engineUpgrade(image=engine_upgrade_image)
    except Exception as e:
        can_not_upgrade = True
        print(e)
    assert can_not_upgrade</code></pre>
</details>
<div class="desc"><p>Test engine upgrade when engine image DaemonSet is not fully
deployed</p>
<p>Prerequisite:
Prepare system for the test by calling the method
prepare_engine_not_fully_deployed_evnironment_with_volumes to have
2 volumes, tainted node and not fully deployed engine.</p>
<ol>
<li>Deploy a new engine image, new-ei</li>
<li>Detach vol-1, verify that you can upgrade vol-1 to new-ei</li>
<li>Detach then attach vol-1 to node-2</li>
<li>Verify that you can live upgrade vol-1 to back to default engine image</li>
<li>Try to upgrade vol-2 to new-ei</li>
<li>Verify that the engineUpgrade API call returns error</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_engine_image_not_fully_deployed_perform_replica_scheduling"><code class="name flex">
<span>def <span class="ident">test_engine_image_not_fully_deployed_perform_replica_scheduling</span></span>(<span>client, core_api)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_engine_image_not_fully_deployed_perform_replica_scheduling(client, core_api): # NOQA
    &#34;&#34;&#34;
    Test replicas scheduling when engine image DaemonSet is not fully
    deployed

    Prerequisite:
    Prepare system for the test by calling the method
    prepare_engine_not_fully_deployed_evnironment to have
    tainted node and not fully deployed engine.

    1. Disable the scheduling for node-2
    2. Create a volume, vol-1, with 2 replicas, attach to node-3
    3. Verify that there is one replica fail to be scheduled
    4. enable the scheduling for node-2
    5. Verify that replicas are scheduled onto node-2 and node-3
    &#34;&#34;&#34;
    tainted_node_id = \
        prepare_engine_not_fully_deployed_environment(client, core_api)

    # node1: tainted node, node2: self host node, node3: the last one
    nodes = client.list_node()
    for node in nodes:
        if node.id == get_self_host_id():
            node2 = node
        elif node.id != tainted_node_id and node.id != get_self_host_id:
            node3 = node

    node2 = set_node_scheduling(client, node2, allowScheduling=False)
    node2 = common.wait_for_node_update(client, node2.id, &#34;allowScheduling&#34;,
                                        False)

    volume1 = create_and_check_volume(client, &#34;vol-1&#34;,
                                      num_of_replicas=2,
                                      size=str(3 * Gi))

    volume1.attach(hostId=node3.id)
    volume1 = wait_for_volume_degraded(client, volume1.name)

    node2 = set_node_scheduling(client, node2, allowScheduling=True)
    node2 = common.wait_for_node_update(client, node2.id,
                                        &#34;allowScheduling&#34;, True)

    volume1 = wait_for_volume_healthy(client, volume1.name)
    on_node2 = False
    on_node3 = False
    on_taint_node = False
    for replica in volume1.replicas:
        if replica.hostId == node2.id:
            on_node2 = True
        elif replica.hostId == node3.id:
            on_node3 = True
        elif replica.hostId == tainted_node_id:
            on_taint_node = True

    assert on_node2
    assert on_node3
    assert not on_taint_node</code></pre>
</details>
<div class="desc"><p>Test replicas scheduling when engine image DaemonSet is not fully
deployed</p>
<p>Prerequisite:
Prepare system for the test by calling the method
prepare_engine_not_fully_deployed_evnironment to have
tainted node and not fully deployed engine.</p>
<ol>
<li>Disable the scheduling for node-2</li>
<li>Create a volume, vol-1, with 2 replicas, attach to node-3</li>
<li>Verify that there is one replica fail to be scheduled</li>
<li>enable the scheduling for node-2</li>
<li>Verify that replicas are scheduled onto node-2 and node-3</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_engine_image_not_fully_deployed_perform_volume_operations"><code class="name flex">
<span>def <span class="ident">test_engine_image_not_fully_deployed_perform_volume_operations</span></span>(<span>client, core_api, set_random_backupstore)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_engine_image_not_fully_deployed_perform_volume_operations(client, core_api, set_random_backupstore): # NOQA
    &#34;&#34;&#34;
    Test volume operations when engine image DaemonSet is not fully
    deployed

    Prerequisite:
    Prepare system for the test by calling the method
    prepare_engine_not_fully_deployed_evnironment_with_volumes to have
    2 volumes, tainted node and not fully deployed engine.

    1. Verify that functions (snapshot, backup, detach) are working ok
       for vol-1
    2. Detach vol-1
    3. Attach vol-1 to node-1. Verify that Longhorn cannot attach vol-1 to
       node-1 since there is no engine image on node-1. The attach API call
       returns error
    4. Verify that we can attach to another node, take snapshot, take a backup,
       expand, then detach vol-1
    5. Verify that vol-2 cannot be attached to tainted nodes. The attach API
       call returns error
    6. Verify that vol-2 can attach to non-tainted node with degrade status
    &#34;&#34;&#34;
    volume1, volume2, tainted_node_id = \
        prepare_engine_not_fully_deployed_environment_with_volumes(client,
                                                                   core_api)

    volume1 = client.by_id_volume(volume1.name)
    volume1 = wait_for_volume_healthy(client, volume1.name)

    # TODO: write data into volume1.
    # Did not do data write because volume is not attached to self host node

    # High chance get error &#34;cannot get engine client&#34; first time take snapshot
    for i in range(RETRY_COUNTS_SHORT):
        try:
            snap1 = create_snapshot(client, volume1.name)
            break
        except Exception:
            time.sleep(RETRY_INTERVAL_LONG)
            continue

    snapshots = volume1.snapshotList()
    snapMap = {}
    for snap in snapshots:
        snapMap[snap.name] = snap

    assert snapMap[snap1.name].name == snap1.name

    volume1.detach()
    volume1 = wait_for_volume_detached(client, volume1.name)

    can_not_attach = False
    try:
        volume1.attach(hostId=tainted_node_id)
    except Exception as e:
        print(e)
        can_not_attach = True

    assert can_not_attach

    volume1.attach(hostId=get_self_host_id())
    volume1 = wait_for_volume_healthy(client, volume1.name)
    snap2_data = write_volume_random_data(volume1)
    snap2 = create_snapshot(client, volume1.name)
    snapshots = volume1.snapshotList()
    snapMap = {}
    for snap in snapshots:
        snapMap[snap.name] = snap

    assert snapMap[snap2.name].name == snap2.name
    check_volume_data(volume1, snap2_data)

    backupstore_test(client, get_self_host_id(), volume1.name,
                     size=str(3 * Gi),
                     compression_method=DEFAULT_BACKUP_COMPRESSION_METHOD)
    expand_size = str(4 * Gi)
    volume1.expand(size=expand_size)
    wait_for_volume_expansion(client, volume1.name)
    volume1 = client.by_id_volume(volume1.name)
    assert volume1.size == expand_size
    check_block_device_size(volume1, int(expand_size))
    check_volume_data(volume1, snap2_data, False)

    can_not_attach = False
    try:
        volume2 = client.by_id_volume(volume2.name)
        volume2.attach(hostId=tainted_node_id)
    except Exception as e:
        print(e)
        can_not_attach = True

    assert can_not_attach

    volume2.attach(hostId=get_self_host_id())
    volume2 = wait_for_volume_degraded(client, volume2.name)</code></pre>
</details>
<div class="desc"><p>Test volume operations when engine image DaemonSet is not fully
deployed</p>
<p>Prerequisite:
Prepare system for the test by calling the method
prepare_engine_not_fully_deployed_evnironment_with_volumes to have
2 volumes, tainted node and not fully deployed engine.</p>
<ol>
<li>Verify that functions (snapshot, backup, detach) are working ok
for vol-1</li>
<li>Detach vol-1</li>
<li>Attach vol-1 to node-1. Verify that Longhorn cannot attach vol-1 to
node-1 since there is no engine image on node-1. The attach API call
returns error</li>
<li>Verify that we can attach to another node, take snapshot, take a backup,
expand, then detach vol-1</li>
<li>Verify that vol-2 cannot be attached to tainted nodes. The attach API
call returns error</li>
<li>Verify that vol-2 can attach to non-tainted node with degrade status</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_ha_backup_deletion_recovery"><code class="name flex">
<span>def <span class="ident">test_ha_backup_deletion_recovery</span></span>(<span>set_random_backupstore, client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_ha_backup_deletion_recovery(set_random_backupstore, client, volume_name):  # NOQA
    &#34;&#34;&#34;
    [HA] Test deleting the restored snapshot and rebuild

    Backupstore: all

    1. Create volume and attach it to the current node.
    2. Write `data` to the volume and create snapshot `snap2`
    3. Backup `snap2` to create a backup.
    4. Create volume `res_volume` from the backup. Check volume `data`.
    5. Check snapshot chain, make sure `backup_snapshot` exists.
    6. Delete the `backup_snapshot` and purge snapshots.
    7. After purge complete, delete one replica to verify rebuild works.

    FIXME: Needs improvement, e.g. rebuild when no snapshot is deleted for
    restored backup.
    &#34;&#34;&#34;
    ha_backup_deletion_recovery_test(client, volume_name, SIZE)</code></pre>
</details>
<div class="desc"><p>[HA] Test deleting the restored snapshot and rebuild</p>
<p>Backupstore: all</p>
<ol>
<li>Create volume and attach it to the current node.</li>
<li>Write <code>data</code> to the volume and create snapshot <code>snap2</code></li>
<li>Backup <code>snap2</code> to create a backup.</li>
<li>Create volume <code>res_volume</code> from the backup. Check volume <code>data</code>.</li>
<li>Check snapshot chain, make sure <code>backup_snapshot</code> exists.</li>
<li>Delete the <code>backup_snapshot</code> and purge snapshots.</li>
<li>After purge complete, delete one replica to verify rebuild works.</li>
</ol>
<p>FIXME: Needs improvement, e.g. rebuild when no snapshot is deleted for
restored backup.</p></div>
</dd>
<dt id="tests.test_ha.test_ha_prohibit_deleting_last_replica"><code class="name flex">
<span>def <span class="ident">test_ha_prohibit_deleting_last_replica</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_ha_prohibit_deleting_last_replica(client, volume_name):  # NOQA
    &#34;&#34;&#34;
    Test prohibiting deleting the last replica

    1. Create volume with one replica and attach to the current node.
    2. Try to delete the replica. It should error out

    FIXME: Move out of test_ha.py
    &#34;&#34;&#34;
    volume = create_and_check_volume(client, volume_name,
                                     num_of_replicas=1)

    host_id = get_self_host_id()
    volume = volume.attach(hostId=host_id)
    volume = wait_for_volume_healthy(client, volume_name)

    assert len(volume.replicas) == 1
    replica0 = volume.replicas[0]

    with pytest.raises(Exception) as e:
        volume.replicaRemove(name=replica0.name)
    assert &#34;no other healthy replica available&#34; in str(e.value)

    cleanup_volume(client, volume)</code></pre>
</details>
<div class="desc"><p>Test prohibiting deleting the last replica</p>
<ol>
<li>Create volume with one replica and attach to the current node.</li>
<li>Try to delete the replica. It should error out</li>
</ol>
<p>FIXME: Move out of test_ha.py</p></div>
</dd>
<dt id="tests.test_ha.test_ha_recovery_with_expansion"><code class="name flex">
<span>def <span class="ident">test_ha_recovery_with_expansion</span></span>(<span>client, volume_name, request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_ha_recovery_with_expansion(client, volume_name, request):   # NOQA
    &#34;&#34;&#34;
    [HA] Test recovery with volume expansion

    1. Create a volume and attach it to the current node.
    2. Write a large amount of data to the volume
    3. Remove one random replica and wait for the rebuilding starts
    4. Expand the volume immediately after the rebuilding start
    5. check and wait for the volume expansion and rebuilding
    6. Write more data to the volume
    7. Remove another replica of volume
    8. Wait volume to start rebuilding and complete
    9. Check the data intacty
    &#34;&#34;&#34;
    original_size = str(3 * Gi)
    expand_size = str(4 * Gi)
    volume = create_and_check_volume(client, volume_name,
                                     num_of_replicas=2,
                                     size=original_size)

    host_id = get_self_host_id()
    volume.attach(hostId=host_id)
    volume = wait_for_volume_healthy(client, volume_name)
    assert len(volume.replicas) == 2
    replica0 = volume.replicas[0]
    assert replica0.name != &#34;&#34;
    replica1 = volume.replicas[1]
    assert replica1.name != &#34;&#34;

    volume_path = get_volume_endpoint(volume)
    tmp_file_path = &#34;/tmp/test-ha-recovery-during-expansion-data1&#34;

    def finalizer():
        exec_cmd = [&#34;rm&#34;, &#34;-rf&#34;, tmp_file_path]
        subprocess.check_output(exec_cmd)

    request.addfinalizer(finalizer)

    # Step 2: prepare data then copy it into the volume
    write_volume_dev_random_mb_data(
        tmp_file_path, 0, DATA_SIZE_IN_MB_4*3)
    cksum1 = get_volume_dev_mb_data_md5sum(
        tmp_file_path, 0, DATA_SIZE_IN_MB_4*3)
    copy_file_to_volume_dev_mb_data(
        tmp_file_path, volume_path, 0, 0, DATA_SIZE_IN_MB_4*3)

    # Step 3: Trigger volume rebuilding first
    volume.replicaRemove(name=replica0.name)
    wait_for_rebuild_start(client, volume_name)
    # Step 4: Then trigger volume expansion immediately
    volume.expand(size=expand_size)
    # Step 5: Wait for volume expansion &amp; rebuilding
    wait_for_volume_expansion(client, volume.name)
    wait_for_rebuild_complete(client, volume.name)
    volume = client.by_id_volume(volume_name)
    check_block_device_size(volume, int(expand_size))

    write_volume_dev_random_mb_data(
        tmp_file_path, 0, DATA_SIZE_IN_MB_4)
    cksum2 = get_volume_dev_mb_data_md5sum(
        tmp_file_path, 0, DATA_SIZE_IN_MB_4)
    copy_file_to_volume_dev_mb_data(
        tmp_file_path, volume_path, 0, 1024, DATA_SIZE_IN_MB_4)

    # Step 7 &amp; 8: Trigger volume rebuilding again after expansion
    volume.replicaRemove(name=replica1.name)
    wait_for_rebuild_start(client, volume_name)
    wait_for_rebuild_complete(client, volume.name)

    volume = wait_for_volume_healthy(client, volume_name)
    assert len(volume.replicas) == 2
    volume = client.by_id_volume(volume_name)
    check_block_device_size(volume, int(expand_size))

    volume_cksum1 = get_volume_dev_mb_data_md5sum(
        volume_path, 0, DATA_SIZE_IN_MB_4*3)
    assert cksum1 == volume_cksum1
    volume_cksum2 = get_volume_dev_mb_data_md5sum(
        volume_path, 1024, DATA_SIZE_IN_MB_4*3)
    assert cksum2 == volume_cksum2

    cleanup_volume(client, volume)</code></pre>
</details>
<div class="desc"><p>[HA] Test recovery with volume expansion</p>
<ol>
<li>Create a volume and attach it to the current node.</li>
<li>Write a large amount of data to the volume</li>
<li>Remove one random replica and wait for the rebuilding starts</li>
<li>Expand the volume immediately after the rebuilding start</li>
<li>check and wait for the volume expansion and rebuilding</li>
<li>Write more data to the volume</li>
<li>Remove another replica of volume</li>
<li>Wait volume to start rebuilding and complete</li>
<li>Check the data intacty</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_ha_salvage"><code class="name flex">
<span>def <span class="ident">test_ha_salvage</span></span>(<span>client, core_api, volume_name, disable_auto_salvage)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest   # NOQA
def test_ha_salvage(client, core_api, volume_name, disable_auto_salvage):  # NOQA
    &#34;&#34;&#34;
    [HA] Test salvage when volume faulted
    TODO
    The test cases should cover the following four cases:
    1. Manual salvage with revision counter enabled.
    2. Manual salvage with revision counter disabled.
    3. Auto salvage with revision counter enabled.
    4. Auto salvage with revision counter enabled.

    Setting: Disable auto salvage

    Case 1: Delete all replica processes using instance manager

    1. Create volume and attach to the current node
    2. Write `data` to the volume.
    3. Crash all the replicas using Instance Manager API
        1. Cannot do it using Longhorn API since a. it will delete data, b. the
    last replica is not allowed to be deleted
    4. Make sure volume detached automatically and changed into `faulted` state
    5. Make sure both replicas reports `failedAt` timestamp.
    6. Salvage the volume
    7. Verify that volume is in `detached` `unknown` state. No longer `faulted`
    8. Verify that all the replicas&#39; `failedAt` timestamp cleaned.
    9. Attach the volume and check `data`

    Case 2: Crash all replica processes

    Same steps as Case 1 except on step 3, use SIGTERM to crash the processes

    Setting: Enabled auto salvage.

    Case 3: Revision counter disabled.

    1. Set &#39;Automatic salvage&#39; to true.
    2. Set &#39;Disable Revision Counter&#39; to true.
    3. Create a volume with 3 replicas.
    4. Attach the volume to a node and write some data to it and save the
    checksum.
    5. Delete all replica processes using instance manager or
    crash all replica processes using SIGTERM.
    6. Wait for volume to `faulted`, then `healthy`.
    7. Verify all 3 replicas are reused successfully.
    8. Check the data in the volume and make sure it&#39;s the same as the
    checksum saved on step 5.

    Case 4: Revision counter enabled.

    1. Set &#39;Automatic salvage&#39; to true.
    2. Set &#39;Disable Revision Counter&#39; to false.
    4. Create a volume with 3 replicas.
    5. Attach the volume to a node and write some data to it and save the
    checksum.
    6. Delete all replica processes using instance manager or
    crash all replica processes using SIGTERM.
    7. Wait for volume to `faulted`, then `healthy`.
    8. Verify there are 3 replicas, they are all from previous replicas.
    9. Check the data in the volume and make sure it&#39;s the same as the
    checksum saved on step 5.

    &#34;&#34;&#34;
    ha_salvage_test(client, core_api, volume_name)</code></pre>
</details>
<div class="desc"><p>[HA] Test salvage when volume faulted
TODO
The test cases should cover the following four cases:
1. Manual salvage with revision counter enabled.
2. Manual salvage with revision counter disabled.
3. Auto salvage with revision counter enabled.
4. Auto salvage with revision counter enabled.</p>
<p>Setting: Disable auto salvage</p>
<p>Case 1: Delete all replica processes using instance manager</p>
<ol>
<li>Create volume and attach to the current node</li>
<li>Write <code>data</code> to the volume.</li>
<li>Crash all the replicas using Instance Manager API<ol>
<li>Cannot do it using Longhorn API since a. it will delete data, b. the
last replica is not allowed to be deleted</li>
</ol>
</li>
<li>Make sure volume detached automatically and changed into <code>faulted</code> state</li>
<li>Make sure both replicas reports <code>failedAt</code> timestamp.</li>
<li>Salvage the volume</li>
<li>Verify that volume is in <code>detached</code> <code>unknown</code> state. No longer <code>faulted</code></li>
<li>Verify that all the replicas' <code>failedAt</code> timestamp cleaned.</li>
<li>Attach the volume and check <code>data</code></li>
</ol>
<p>Case 2: Crash all replica processes</p>
<p>Same steps as Case 1 except on step 3, use SIGTERM to crash the processes</p>
<p>Setting: Enabled auto salvage.</p>
<p>Case 3: Revision counter disabled.</p>
<ol>
<li>Set 'Automatic salvage' to true.</li>
<li>Set 'Disable Revision Counter' to true.</li>
<li>Create a volume with 3 replicas.</li>
<li>Attach the volume to a node and write some data to it and save the
checksum.</li>
<li>Delete all replica processes using instance manager or
crash all replica processes using SIGTERM.</li>
<li>Wait for volume to <code>faulted</code>, then <code>healthy</code>.</li>
<li>Verify all 3 replicas are reused successfully.</li>
<li>Check the data in the volume and make sure it's the same as the
checksum saved on step 5.</li>
</ol>
<p>Case 4: Revision counter enabled.</p>
<ol>
<li>Set 'Automatic salvage' to true.</li>
<li>Set 'Disable Revision Counter' to false.</li>
<li>Create a volume with 3 replicas.</li>
<li>Attach the volume to a node and write some data to it and save the
checksum.</li>
<li>Delete all replica processes using instance manager or
crash all replica processes using SIGTERM.</li>
<li>Wait for volume to <code>faulted</code>, then <code>healthy</code>.</li>
<li>Verify there are 3 replicas, they are all from previous replicas.</li>
<li>Check the data in the volume and make sure it's the same as the
checksum saved on step 5.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_ha_simple_recovery"><code class="name flex">
<span>def <span class="ident">test_ha_simple_recovery</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
@pytest.mark.coretest   # NOQA
def test_ha_simple_recovery(client, volume_name):  # NOQA
    &#34;&#34;&#34;
    [HA] Test recovering from one replica failure

    1. Create volume and attach to the current node
    2. Write `data` to the volume.
    3. Remove one of the replica using Longhorn API
    4. Wait for a new replica to be rebuilt.
    5. Check the volume data
    &#34;&#34;&#34;
    ha_simple_recovery_test(client, volume_name, SIZE)</code></pre>
</details>
<div class="desc"><p>[HA] Test recovering from one replica failure</p>
<ol>
<li>Create volume and attach to the current node</li>
<li>Write <code>data</code> to the volume.</li>
<li>Remove one of the replica using Longhorn API</li>
<li>Wait for a new replica to be rebuilt.</li>
<li>Check the volume data</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_inc_restoration_with_multiple_rebuild_and_expansion"><code class="name flex">
<span>def <span class="ident">test_inc_restoration_with_multiple_rebuild_and_expansion</span></span>(<span>set_random_backupstore,<br>client,<br>core_api,<br>volume_name,<br>storage_class,<br>csi_pv,<br>pvc,<br>pod_make)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_inc_restoration_with_multiple_rebuild_and_expansion(set_random_backupstore, client, core_api, volume_name, storage_class, csi_pv, pvc, pod_make): # NOQA
    &#34;&#34;&#34;
    [HA] Test if the rebuild is disabled for the DR volume
    1. Setup a random backupstore.
    2. Create a pod with a volume and wait for pod to start.
    3. Write data to the volume and get the md5sum.
    4. Create the 1st backup for the volume.
    5. Create a DR volume based on the backup
       and wait for the init restoration complete.
    6. Shutdown the pod and wait for the std volume detached.
    7. Offline expand the std volume and wait for expansion complete.
    8. Re-launch a pod for the std volume.
    9. Write more data to the std volume. Make sure there is data in the
       expanded part.
    10. Create the 2nd backup and wait for the backup creation complete.
    11. For the DR volume, delete one replica and trigger incremental restore
        simultaneously.
    12. Wait for the inc restoration complete and the volume becoming Healthy.
    13. Check the DR volume size and snapshot info. Make sure there is only
        one snapshot in the volume.
    14. Online expand the std volume and wait for expansion complete.
    15. Write data to the std volume then create the 3rd backup.
    16. Trigger the inc restore then re-verify the snapshot info.
    17. Activate the DR volume.
    18. Create PV/PVC/Pod for the activated volume
        and wait for the pod start.
    19. Check if the restored volume is state `healthy`
        after the attachment.
    20. Check md5sum of the data in the activated volume.
    21. Crash one random replica. Then verify the rebuild still works fine for
        the activated volume.
    22. Do cleanup.
    &#34;&#34;&#34;
    update_setting(client, common.SETTING_DEGRADED_AVAILABILITY, &#34;false&#34;)
    create_storage_class(storage_class)

    original_size = 1 * Gi
    std_pod_name = &#39;std-pod-for-dr-expansion-and-rebuilding&#39;
    std_pvc_name = &#34;pvc-&#34; + std_pod_name
    pvc[&#39;metadata&#39;][&#39;name&#39;] = std_pvc_name
    pvc[&#39;spec&#39;][&#39;storageClassName&#39;] = storage_class[&#39;metadata&#39;][&#39;name&#39;]
    pvc[&#39;spec&#39;][&#39;resources&#39;][&#39;requests&#39;][&#39;storage&#39;] = \
        str(original_size)
    create_pvc(pvc)

    std_pod_manifest = pod_make(name=std_pod_name)
    std_pod_manifest[&#39;spec&#39;][&#39;volumes&#39;] = [create_pvc_spec(std_pvc_name)]
    create_and_wait_pod(core_api, std_pod_manifest)

    std_pv = wait_and_get_pv_for_pvc(core_api, std_pvc_name)
    assert std_pv.status.phase == &#34;Bound&#34;
    std_volume_name = std_pv.spec.csi.volume_handle
    std_volume = wait_for_volume_healthy(client, std_volume_name)

    # Create the 1st backup.
    data_path1 = &#34;/data/test1&#34;
    write_pod_volume_random_data(core_api, std_pod_name,
                                 data_path1, DATA_SIZE_IN_MB_4)
    std_md5sum1 = get_pod_data_md5sum(core_api, std_pod_name, data_path1)

    snap1 = create_snapshot(client, std_volume_name)
    std_volume.snapshotBackup(name=snap1.name)
    wait_for_backup_completion(client,
                               std_volume_name,
                               snap1.name,
                               retry_count=600)
    bv, b1 = find_backup(client, std_volume_name, snap1.name)

    # Create the DR volume
    dr_volume_name = volume_name + &#34;-dr&#34;
    client.create_volume(name=dr_volume_name, size=str(1 * Gi),
                         numberOfReplicas=3, fromBackup=b1.url,
                         frontend=&#34;&#34;, standby=True)
    wait_for_volume_creation(client, dr_volume_name)
    wait_for_volume_healthy_no_frontend(client, dr_volume_name)
    wait_for_backup_restore_completed(client, dr_volume_name, b1.name)

    # Step 7: Do offline expansion for the std volume.
    delete_and_wait_pod(core_api, std_pod_name)
    wait_for_volume_detached(client, std_volume_name)
    expand_size1 = 2 * Gi
    expand_and_wait_for_pvc(core_api, pvc, expand_size1)
    wait_for_volume_expansion(client, std_volume_name)
    std_volume = wait_for_volume_detached(client, std_volume_name)
    assert std_volume.size == str(expand_size1)

    # Re-launch the pod
    create_and_wait_pod(core_api, std_pod_manifest)
    wait_for_volume_healthy(client, std_volume_name)

    # Step 9:
    # When the total written data size is more than 1Gi, there must be data in
    # the expanded part.
    data_path2 = &#34;/data/test2&#34;
    write_pod_volume_random_data(core_api, std_pod_name,
                                 data_path2, DATA_SIZE_IN_MB_4)
    std_md5sum2 = get_pod_data_md5sum(core_api, std_pod_name, data_path2)
    snap2 = create_snapshot(client, std_volume_name)
    std_volume = client.by_id_volume(std_volume_name)
    std_volume.snapshotBackup(name=snap2.name)
    wait_for_backup_completion(client, std_volume_name, snap2.name,
                               retry_count=600)
    bv, b2 = find_backup(client, std_volume_name, snap2.name)

    # Step 11:
    # Pick up a random replica and fail it.
    # Then trigger rebuild and the incremental restoration
    dr_volume = client.by_id_volume(dr_volume_name)
    for r in dr_volume.replicas:
        failed_replica = r.name
        break
    assert failed_replica
    dr_volume.replicaRemove(name=failed_replica)
    client.list_backupVolume()

    # Wait for the rebuild start
    wait_for_volume_degraded(client, dr_volume_name)
    running_replica_count = 0
    for i in range(RETRY_COUNTS):
        running_replica_count = 0
        dr_volume = client.by_id_volume(dr_volume_name)
        for r in dr_volume.replicas:
            if r[&#39;running&#39;] and not r[&#39;failedAt&#39;]:
                running_replica_count += 1
        if running_replica_count == 3:
            break
        time.sleep(RETRY_INTERVAL)
    assert running_replica_count == 3

    # Wait for inc restoration &amp; rebuild complete
    wait_for_dr_volume_expansion(client, dr_volume_name, str(expand_size1))
    wait_for_volume_healthy_no_frontend(client, dr_volume_name)
    check_volume_last_backup(client, dr_volume_name, b2.name)

    # Verify the snapshot info
    dr_volume = client.by_id_volume(dr_volume_name)
    assert dr_volume.size == str(expand_size1)
    wait_for_snapshot_count(dr_volume, 2, count_removed=True)
    snapshots = dr_volume.snapshotList(volume=dr_volume_name)
    for snap in snapshots:
        if snap[&#34;name&#34;] != &#34;volume-head&#34;:
            assert snap[&#34;name&#34;] == &#34;expand-&#34; + str(expand_size1)
            assert not snap[&#34;usercreated&#34;]
            assert &#34;volume-head&#34; in snap[&#34;children&#34;]

    # Step 14: Do online expansion for the std volume.
    expand_size2 = 3 * Gi
    expand_and_wait_for_pvc(core_api, pvc, expand_size2)
    wait_for_volume_expansion(client, std_volume_name)

    # Step 15:
    # When the total written data size is more than 2Gi, there must be data in
    # the 2nd expanded part.
    data_path3 = &#34;/data/test3&#34;
    write_pod_volume_random_data(core_api, std_pod_name,
                                 data_path3, DATA_SIZE_IN_MB_4)
    std_md5sum3 = get_pod_data_md5sum(core_api, std_pod_name, data_path3)
    # Then create the 3rd backup for the std volume
    snap3 = create_snapshot(client, std_volume_name)
    std_volume = client.by_id_volume(std_volume_name)
    std_volume.snapshotBackup(name=snap3.name)
    wait_for_backup_completion(client, std_volume_name, snap3.name)
    bv, b3 = find_backup(client, std_volume_name, snap3.name)

    # Step 16:
    # Trigger the restoration for the DR volume.
    client.list_backupVolume()
    check_volume_last_backup(client, dr_volume_name, b3.name)
    wait_for_dr_volume_expansion(client, dr_volume_name, str(expand_size2))
    # Then re-verify the snapshot info
    dr_volume = client.by_id_volume(dr_volume_name)
    assert dr_volume.size == str(expand_size2)
    wait_for_snapshot_count(dr_volume, 2, count_removed=True)
    snapshots = dr_volume.snapshotList(volume=dr_volume_name)
    for snap in snapshots:
        if snap[&#34;name&#34;] != &#34;volume-head&#34;:
            assert snap[&#34;name&#34;] == &#34;expand-&#34; + str(expand_size2)
            assert not snap[&#34;usercreated&#34;]
            assert &#34;volume-head&#34; in snap[&#34;children&#34;]

    activate_standby_volume(client, dr_volume_name)
    wait_for_volume_detached(client, dr_volume_name)

    dr_pod_name = dr_volume_name + &#34;-pod&#34;
    dr_pv_name = dr_volume_name + &#34;-pv&#34;
    dr_pvc_name = dr_volume_name + &#34;-pvc&#34;
    dr_pod = pod_make(name=dr_pod_name)
    create_pv_for_volume(client, core_api, dr_volume, dr_pv_name)
    create_pvc_for_volume(client, core_api, dr_volume, dr_pvc_name)
    dr_pod[&#39;spec&#39;][&#39;volumes&#39;] = [create_pvc_spec(dr_pvc_name)]
    create_and_wait_pod(core_api, dr_pod)
    dr_volume = wait_for_volume_healthy(client, dr_volume_name)

    md5sum1 = get_pod_data_md5sum(core_api, dr_pod_name, data_path1)
    assert std_md5sum1 == md5sum1
    md5sum2 = get_pod_data_md5sum(core_api, dr_pod_name, data_path2)
    assert std_md5sum2 == md5sum2
    md5sum3 = get_pod_data_md5sum(core_api, dr_pod_name, data_path3)
    assert std_md5sum3 == md5sum3

    failed_replica = dr_volume.replicas[0]
    crash_replica_processes(client, core_api, dr_volume_name,
                            replicas=[failed_replica],
                            wait_to_fail=False)
    wait_for_volume_degraded(client, dr_volume_name)
    wait_for_volume_healthy(client, dr_volume_name)

    # Check if the activated volume still works fine after the rebuild
    write_pod_volume_data(core_api, dr_pod_name, &#39;longhorn-integration-test&#39;,
                          filename=&#39;test4&#39;)
    read_data = read_volume_data(core_api, dr_pod_name, &#39;test4&#39;)
    assert read_data == &#39;longhorn-integration-test&#39;

    # cleanup
    backupstore_cleanup(client)</code></pre>
</details>
<div class="desc"><p>[HA] Test if the rebuild is disabled for the DR volume
1. Setup a random backupstore.
2. Create a pod with a volume and wait for pod to start.
3. Write data to the volume and get the md5sum.
4. Create the 1st backup for the volume.
5. Create a DR volume based on the backup
and wait for the init restoration complete.
6. Shutdown the pod and wait for the std volume detached.
7. Offline expand the std volume and wait for expansion complete.
8. Re-launch a pod for the std volume.
9. Write more data to the std volume. Make sure there is data in the
expanded part.
10. Create the 2nd backup and wait for the backup creation complete.
11. For the DR volume, delete one replica and trigger incremental restore
simultaneously.
12. Wait for the inc restoration complete and the volume becoming Healthy.
13. Check the DR volume size and snapshot info. Make sure there is only
one snapshot in the volume.
14. Online expand the std volume and wait for expansion complete.
15. Write data to the std volume then create the 3rd backup.
16. Trigger the inc restore then re-verify the snapshot info.
17. Activate the DR volume.
18. Create PV/PVC/Pod for the activated volume
and wait for the pod start.
19. Check if the restored volume is state <code>healthy</code>
after the attachment.
20. Check md5sum of the data in the activated volume.
21. Crash one random replica. Then verify the rebuild still works fine for
the activated volume.
22. Do cleanup.</p></div>
</dd>
<dt id="tests.test_ha.test_rebuild_after_replica_file_crash"><code class="name flex">
<span>def <span class="ident">test_rebuild_after_replica_file_crash</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_rebuild_after_replica_file_crash(client, volume_name): # NOQA
    &#34;&#34;&#34;
    [HA] Test replica rebuild should be triggered if any crashes happened.

    1. Create a longhorn volume with replicas.
    2. Write random data to the volume and get the md5sum.
    3. Remove file `volume-head-000.img` from one of the replicas.
    4. Wait replica rebuild to be triggered.
    5. Verify the old replica containing the crashed file will be reused.
    6. Read the data from the volume and verify the md5sum.
    &#34;&#34;&#34;
    replica_count = 3
    volume = create_and_check_volume(client, volume_name,
                                     num_of_replicas=replica_count)
    host_id = get_self_host_id()
    volume = volume.attach(hostId=host_id)
    volume = wait_for_volume_healthy(client, volume_name)
    data = write_volume_random_data(volume)

    replica = None
    for rep in volume.replicas:
        if rep[&#34;hostId&#34;] == host_id:
            replica = rep
            break
    assert replica is not None

    volume_head_file_path = replica[&#34;dataPath&#34;] + &#34;/volume-head-000.img&#34;

    exec_cmd = [&#34;rm&#34;, volume_head_file_path]

    try:
        subprocess.check_output(exec_cmd)
    except subprocess.CalledProcessError as e:
        print(e.output)

    wait_for_volume_degraded(client, volume_name)
    wait_for_rebuild_complete(client, volume_name)
    wait_for_volume_healthy(client, volume_name)

    volume = client.by_id_volume(volume_name)

    reused_replica = None
    for rep in volume.replicas:
        if rep[&#34;name&#34;] == replica[&#34;name&#34;]:
            reused_replica = rep
            break

    assert reused_replica[&#34;running&#34;] is True
    assert reused_replica[&#34;mode&#34;] == &#34;RW&#34;
    assert not reused_replica[&#34;failedAt&#34;]

    check_volume_data(volume, data)</code></pre>
</details>
<div class="desc"><p>[HA] Test replica rebuild should be triggered if any crashes happened.</p>
<ol>
<li>Create a longhorn volume with replicas.</li>
<li>Write random data to the volume and get the md5sum.</li>
<li>Remove file <code>volume-head-000.img</code> from one of the replicas.</li>
<li>Wait replica rebuild to be triggered.</li>
<li>Verify the old replica containing the crashed file will be reused.</li>
<li>Read the data from the volume and verify the md5sum.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_rebuild_failure_with_intensive_data"><code class="name flex">
<span>def <span class="ident">test_rebuild_failure_with_intensive_data</span></span>(<span>client, core_api, volume_name, csi_pv, pvc, pod_make)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_rebuild_failure_with_intensive_data(client, core_api, volume_name, csi_pv, pvc, pod_make):  # NOQA
    &#34;&#34;&#34;
    [HA] Test rebuild failure with intensive data writing

    1. Create PV/PVC/POD with livenss check
    2. Create volume and wait for pod to start
    3. Write data to `/data/test1` inside the pod and get `original_checksum_1`
    4. Write data to `/data/test2` inside the pod and get `original_checksum_2`
    5. Find running replicas of the volume
    6. Crash one of the running replicas.
    7. Wait for the replica rebuild to start
    8. Crash the replica which is sending data to the rebuilding replica
    9. Wait for volume to finish two rebuilds and become healthy
    10. Check md5sum for both data location
    &#34;&#34;&#34;

    data_path_1 = &#34;/data/test1&#34;
    data_path_2 = &#34;/data/test2&#34;
    pod_name, pv_name, pvc_name, original_md5sum_1 = \
        prepare_pod_with_data_in_mb(
            client, core_api, csi_pv, pvc, pod_make, volume_name,
            volume_size=str(2*Gi),
            data_path=data_path_1, data_size_in_mb=DATA_SIZE_IN_MB_4)
    create_snapshot(client, volume_name)
    write_pod_volume_random_data(core_api, pod_name,
                                 data_path_2, DATA_SIZE_IN_MB_4)
    original_md5sum_2 = get_pod_data_md5sum(core_api, pod_name, data_path_2)

    volume = client.by_id_volume(volume_name)
    replicas = []
    for r in volume.replicas:
        if r.running:
            replicas.append(r)
        else:
            volume.replicaRemove(name=r.name)
    assert len(replicas) == 3
    random.shuffle(replicas)
    # Trigger rebuild
    crash_replica_processes(client, core_api, volume_name, [replicas[0]])
    wait_for_volume_degraded(client, volume_name)
    # Trigger rebuild failure by
    # crashing the replica which is sending data to the rebuilding replica
    from_replica_name, _ = wait_for_rebuild_start(client, volume_name)
    for r in replicas:
        if r.name == from_replica_name:
            from_replica = r
    assert from_replica
    crash_replica_processes(client, core_api, volume_name, [from_replica])
    wait_for_volume_healthy(client, volume_name)
    md5sum_1 = get_pod_data_md5sum(core_api, pod_name, data_path_1)
    assert original_md5sum_1 == md5sum_1
    md5sum_2 = get_pod_data_md5sum(core_api, pod_name, data_path_2)
    assert original_md5sum_2 == md5sum_2</code></pre>
</details>
<div class="desc"><p>[HA] Test rebuild failure with intensive data writing</p>
<ol>
<li>Create PV/PVC/POD with livenss check</li>
<li>Create volume and wait for pod to start</li>
<li>Write data to <code>/data/test1</code> inside the pod and get <code>original_checksum_1</code></li>
<li>Write data to <code>/data/test2</code> inside the pod and get <code>original_checksum_2</code></li>
<li>Find running replicas of the volume</li>
<li>Crash one of the running replicas.</li>
<li>Wait for the replica rebuild to start</li>
<li>Crash the replica which is sending data to the rebuilding replica</li>
<li>Wait for volume to finish two rebuilds and become healthy</li>
<li>Check md5sum for both data location</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_rebuild_replica_and_from_replica_on_the_same_node"><code class="name flex">
<span>def <span class="ident">test_rebuild_replica_and_from_replica_on_the_same_node</span></span>(<span>client, core_api, volume_name, csi_pv, pvc, pod_make)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_rebuild_replica_and_from_replica_on_the_same_node(client, core_api, volume_name, csi_pv, pvc, pod_make):  # NOQA
    &#34;&#34;&#34;
    [HA] Test the corner case that the from-replica and the rebuilding replica
    are on the same node

    Test prerequisites:
      - set Replica Node Level Soft Anti-Affinity disabled

    1. Disable the setting replica-soft-anti-affinity.
    2. Set replica replenishment wait interval to an appropriate value.
    3. Create a pod with Longhorn volume and wait for pod to start
    4. Write data to `/data/test` inside the pod and get `original_checksum`
    5. Disable scheduling for all nodes except for one.
    6. Find running replicas of the volume
    7. Crash 2 running replicas.
    8. Wait for the replica rebuild to start.
    9. Check if the rebuilding replica is one of the crashed replica,
       and this reused replica is rebuilt on the only available node.
    10. Check md5sum for the written data
    &#34;&#34;&#34;

    replica_node_soft_anti_affinity_setting = \
        client.by_id_setting(SETTING_REPLICA_NODE_SOFT_ANTI_AFFINITY)
    client.update(replica_node_soft_anti_affinity_setting, value=&#34;false&#34;)
    replenish_wait_setting = \
        client.by_id_setting(SETTING_REPLICA_REPLENISHMENT_WAIT_INTERVAL)
    client.update(replenish_wait_setting, value=&#34;600&#34;)

    data_path = &#34;/data/test&#34;
    pod_name, pv_name, pvc_name, original_md5sum = \
        prepare_pod_with_data_in_mb(
            client, core_api, csi_pv, pvc, pod_make, volume_name,
            volume_size=str(2*Gi),
            data_path=data_path, data_size_in_mb=2*Gi)

    volume = client.by_id_volume(volume_name)
    original_replicas = volume.replicas
    assert len(original_replicas) == 3

    available_node_name = original_replicas[0].hostId
    nodes = client.list_node()
    assert len(nodes) &gt; 0
    for node in nodes:
        if node.name == available_node_name:
            continue
        node = set_node_scheduling(client, node, allowScheduling=False)
        common.wait_for_node_update(client, node.id,
                                    &#34;allowScheduling&#34;, False)

    # Trigger rebuild
    crash_replica_processes(client, core_api, volume_name,
                            [original_replicas[0], original_replicas[1]])
    wait_for_volume_degraded(client, volume_name)
    from_replica_name, rebuilding_replica_name = \
        wait_for_rebuild_start(client, volume_name)
    assert from_replica_name != rebuilding_replica_name
    assert from_replica_name == original_replicas[2].name
    assert rebuilding_replica_name == original_replicas[0].name

    # Wait for volume healthy and
    # check if the failed replica on the only available node is reused.
    wait_for_rebuild_complete(client, volume_name)
    volume = wait_for_volume_degraded(client, volume_name)
    assert volume.robustness == &#34;degraded&#34;
    for r in volume.replicas:
        if r.name == rebuilding_replica_name:
            assert r.hostId == available_node_name

    md5sum = get_pod_data_md5sum(core_api, pod_name, data_path)
    assert original_md5sum == md5sum</code></pre>
</details>
<div class="desc"><p>[HA] Test the corner case that the from-replica and the rebuilding replica
are on the same node</p>
<p>Test prerequisites:
- set Replica Node Level Soft Anti-Affinity disabled</p>
<ol>
<li>Disable the setting replica-soft-anti-affinity.</li>
<li>Set replica replenishment wait interval to an appropriate value.</li>
<li>Create a pod with Longhorn volume and wait for pod to start</li>
<li>Write data to <code>/data/test</code> inside the pod and get <code>original_checksum</code></li>
<li>Disable scheduling for all nodes except for one.</li>
<li>Find running replicas of the volume</li>
<li>Crash 2 running replicas.</li>
<li>Wait for the replica rebuild to start.</li>
<li>Check if the rebuilding replica is one of the crashed replica,
and this reused replica is rebuilt on the only available node.</li>
<li>Check md5sum for the written data</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_rebuild_with_inc_restoration"><code class="name flex">
<span>def <span class="ident">test_rebuild_with_inc_restoration</span></span>(<span>set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_rebuild_with_inc_restoration(set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make):  # NOQA
    &#34;&#34;&#34;
    [HA] Test if the rebuild is disabled for the DR volume
    1. Setup a random backupstore.
    2. Create a pod with a volume and wait for pod to start.
    3. Write data to `/data/test1` inside the pod and get the md5sum.
    4. Create the 1st backup for the volume.
    5. Create a DR volume based on the backup
       and wait for the init restoration complete.
    6. Write more data to the original volume then create the 2nd backup.
    7. Delete one replica and trigger incremental restore simultaneously.
    8. Wait for the inc restoration complete and the volume becoming Healthy.
    9. Activate the DR volume.
    10. Create PV/PVC/Pod for the activated volume
        and wait for the pod start.
    11. Check if the restored volume is state `healthy`
        after the attachment.
    12. Check md5sum of the data in the activated volume.
    13. Do cleanup.
    &#34;&#34;&#34;
    update_setting(client, common.SETTING_DEGRADED_AVAILABILITY, &#34;false&#34;)

    std_volume_name = volume_name + &#34;-std&#34;
    data_path1 = &#34;/data/test1&#34;
    std_pod_name, std_pv_name, std_pvc_name, std_md5sum1 = \
        prepare_pod_with_data_in_mb(
            client, core_api, csi_pv, pvc, pod_make, std_volume_name,
            volume_size=str(2*Gi),
            data_path=data_path1, data_size_in_mb=DATA_SIZE_IN_MB_2)

    std_volume = client.by_id_volume(std_volume_name)
    snap1 = create_snapshot(client, std_volume_name)
    std_volume.snapshotBackup(name=snap1.name)
    wait_for_backup_completion(client, std_volume_name, snap1.name)
    bv, b1 = find_backup(client, std_volume_name, snap1.name)

    dr_volume_name = volume_name + &#34;-dr&#34;
    client.create_volume(name=dr_volume_name, size=str(2*Gi),
                         numberOfReplicas=3, fromBackup=b1.url,
                         frontend=&#34;&#34;, standby=True,
                         dataEngine=DATA_ENGINE)
    wait_for_volume_creation(client, dr_volume_name)
    wait_for_backup_restore_completed(client, dr_volume_name, b1.name)

    data_path2 = &#34;/data/test2&#34;
    write_pod_volume_random_data(core_api, std_pod_name,
                                 data_path2, DATA_SIZE_IN_MB_4)
    std_md5sum2 = get_pod_data_md5sum(core_api, std_pod_name, data_path2)
    snap2 = create_snapshot(client, std_volume_name)
    std_volume.snapshotBackup(name=snap2.name)
    wait_for_backup_completion(client, std_volume_name, snap2.name)
    bv, b2 = find_backup(client, std_volume_name, snap2.name)

    # Trigger rebuild during the incremental restoration
    wait_for_volume_restoration_start(client, dr_volume_name, b2.name)
    dr_volume = client.by_id_volume(dr_volume_name)
    for r in dr_volume.replicas:
        failed_replica = r.name
        break
    assert failed_replica
    dr_volume.replicaRemove(name=failed_replica)
    client.list_backupVolume()

    wait_for_volume_degraded(client, dr_volume_name)

    # Wait for the rebuild start
    running_replica_count = 0
    for i in range(RETRY_COUNTS):
        running_replica_count = 0
        dr_volume = client.by_id_volume(dr_volume_name)
        for r in dr_volume.replicas:
            if r[&#39;running&#39;] and not r[&#39;failedAt&#39;]:
                running_replica_count += 1
        if running_replica_count == 3:
            break
        time.sleep(RETRY_INTERVAL)
    assert running_replica_count == 3

    # Wait for inc restoration &amp; rebuild complete
    wait_for_volume_healthy_no_frontend(client, dr_volume_name)
    check_volume_last_backup(client, dr_volume_name, b2.name)

    activate_standby_volume(client, dr_volume_name)
    wait_for_volume_detached(client, dr_volume_name)

    dr_pod_name = dr_volume_name + &#34;-pod&#34;
    dr_pv_name = dr_volume_name + &#34;-pv&#34;
    dr_pvc_name = dr_volume_name + &#34;-pvc&#34;
    dr_pod = pod_make(name=dr_pod_name)
    create_pv_for_volume(client, core_api, dr_volume, dr_pv_name)
    create_pvc_for_volume(client, core_api, dr_volume, dr_pvc_name)
    dr_pod[&#39;spec&#39;][&#39;volumes&#39;] = [create_pvc_spec(dr_pvc_name)]
    create_and_wait_pod(core_api, dr_pod)

    dr_volume = client.by_id_volume(dr_volume_name)
    assert dr_volume[VOLUME_FIELD_ROBUSTNESS] == VOLUME_ROBUSTNESS_HEALTHY

    md5sum1 = get_pod_data_md5sum(core_api, dr_pod_name, data_path1)
    assert std_md5sum1 == md5sum1
    md5sum2 = get_pod_data_md5sum(core_api, dr_pod_name, data_path2)
    assert std_md5sum2 == md5sum2

    # cleanup
    backupstore_cleanup(client)</code></pre>
</details>
<div class="desc"><p>[HA] Test if the rebuild is disabled for the DR volume
1. Setup a random backupstore.
2. Create a pod with a volume and wait for pod to start.
3. Write data to <code>/data/test1</code> inside the pod and get the md5sum.
4. Create the 1st backup for the volume.
5. Create a DR volume based on the backup
and wait for the init restoration complete.
6. Write more data to the original volume then create the 2nd backup.
7. Delete one replica and trigger incremental restore simultaneously.
8. Wait for the inc restoration complete and the volume becoming Healthy.
9. Activate the DR volume.
10. Create PV/PVC/Pod for the activated volume
and wait for the pod start.
11. Check if the restored volume is state <code>healthy</code>
after the attachment.
12. Check md5sum of the data in the activated volume.
13. Do cleanup.</p></div>
</dd>
<dt id="tests.test_ha.test_rebuild_with_restoration"><code class="name flex">
<span>def <span class="ident">test_rebuild_with_restoration</span></span>(<span>set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_rebuild_with_restoration(set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make): # NOQA
    &#34;&#34;&#34;
    [HA] Test if the rebuild is disabled for the restoring volume.

    This is similar to test_single_replica_restore_failure and
    test_single_replica_unschedulable_restore_failure. In this version, a
    replica is deleted. We expect a new replica to be rebuilt in its place and
    the restore to complete.

    1. Setup a random backupstore.
    2. Do cleanup for the backupstore.
    3. Create a pod with a volume and wait for pod to start.
    4. Write data to the pod volume and get the md5sum.
    5. Create a backup for the volume.
    6. Restore a volume from the backup.
    7. Wait for the volume restore start.
    8. Delete one replica during the restoration.
    9. Wait for the restoration complete and the volume detached.
    10. Check if the replica is rebuilt.
    11. Create PV/PVC/Pod for the restored volume and wait for the pod start.
    12. Check if the restored volume is state `Healthy`
        after the attachment.
    13. Check md5sum of the data in the restored volume.
    14. Do cleanup.
    &#34;&#34;&#34;
    restore_with_replica_failure(client, core_api, volume_name, csi_pv, pvc,
                                 pod_make, False, False,
                                 REPLICA_FAILURE_MODE_DELETE)</code></pre>
</details>
<div class="desc"><p>[HA] Test if the rebuild is disabled for the restoring volume.</p>
<p>This is similar to test_single_replica_restore_failure and
test_single_replica_unschedulable_restore_failure. In this version, a
replica is deleted. We expect a new replica to be rebuilt in its place and
the restore to complete.</p>
<ol>
<li>Setup a random backupstore.</li>
<li>Do cleanup for the backupstore.</li>
<li>Create a pod with a volume and wait for pod to start.</li>
<li>Write data to the pod volume and get the md5sum.</li>
<li>Create a backup for the volume.</li>
<li>Restore a volume from the backup.</li>
<li>Wait for the volume restore start.</li>
<li>Delete one replica during the restoration.</li>
<li>Wait for the restoration complete and the volume detached.</li>
<li>Check if the replica is rebuilt.</li>
<li>Create PV/PVC/Pod for the restored volume and wait for the pod start.</li>
<li>Check if the restored volume is state <code>Healthy</code>
after the attachment.</li>
<li>Check md5sum of the data in the restored volume.</li>
<li>Do cleanup.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_recovery_from_im_deletion"><code class="name flex">
<span>def <span class="ident">test_recovery_from_im_deletion</span></span>(<span>client, core_api, volume_name, make_deployment_with_pvc, pvc)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_recovery_from_im_deletion(client, core_api, volume_name, make_deployment_with_pvc, pvc): # NOQA
    &#34;&#34;&#34;
    Related issue :
    https://github.com/longhorn/longhorn/issues/3070

    Steps:
    1. Create a volume and PV/PVC.
    2. Create a deployment with 1 pod having below in command section on node-1
       and attach to the volume.
       command:
          - &#34;/bin/sh&#34;
          - &#34;-ec&#34;
          - |
            touch /data/test
            tail -f /data/test
    3. Wait for the pod to become healthy.
    4. Write small(100MB) data.
    5. Kill the instance-manager-e on node-1.
    6. Wait for the instance-manager-e pod to become healthy.
    7. Wait for pod to get terminated and recreated.
    8. Read and write in the pod to verify the pod is accessible.
    &#34;&#34;&#34;

    # Step1
    client.create_volume(name=volume_name, size=str(1 * Gi),
                         dataEngine=DATA_ENGINE)
    volume = wait_for_volume_detached(client, volume_name)
    pvc_name = volume_name + &#34;-pvc&#34;
    create_pv_for_volume(client, core_api, volume, volume_name)
    create_pvc_for_volume(client, core_api, volume, pvc_name)

    # Step2
    command = [
        &#34;/bin/sh&#34;,
        &#34;-ec&#34;,
        &#34;touch /data/test\ntail -f /data/test\n&#34;
        ]
    deployment_name = volume_name + &#34;-dep&#34;
    deployment = make_deployment_with_pvc(deployment_name, pvc_name)
    deployment[&#34;spec&#34;][&#34;template&#34;][&#34;spec&#34;][&#34;containers&#34;][0][&#34;command&#34;] \
        = command

    # Step3
    apps_api = get_apps_api_client()
    create_and_wait_deployment(apps_api, deployment)

    # Step4
    pod_names = common.get_deployment_pod_names(core_api, deployment)
    test_data = generate_random_data(VOLUME_RWTEST_SIZE)
    write_pod_volume_data(core_api, pod_names[0], test_data, filename=&#39;test&#39;)
    create_snapshot(client, volume_name)

    # Step5, 6
    volume = client.by_id_volume(volume_name)
    im_name = volume[&#34;controllers&#34;][0][&#34;instanceManagerName&#34;]
    exec_cmd = [&#34;kubectl&#34;, &#34;delete&#34;, &#34;pod&#34;,  im_name, &#34;-n&#34;, LONGHORN_NAMESPACE]
    subprocess.check_output(exec_cmd)

    target_pod = \
        core_api.read_namespaced_pod(name=pod_names[0], namespace=&#39;default&#39;)
    wait_delete_pod(core_api, target_pod.metadata.uid)

    # Step7
    pod_names = common.get_deployment_pod_names(core_api, deployment)
    wait_pod(pod_names[0])

    command = &#39;cat /data/test&#39;
    for i in range(RETRY_COMMAND_COUNT):
        try:
            to_be_verified_data = exec_command_in_pod(
                core_api, command, pod_names[0], &#39;default&#39;)
            if test_data == to_be_verified_data:
                break
        except Exception as e:
            print(e)
        finally:
            time.sleep(RETRY_INTERVAL)

    # Step8
    assert test_data == to_be_verified_data</code></pre>
</details>
<div class="desc"><p>Related issue :
<a href="https://github.com/longhorn/longhorn/issues/3070">https://github.com/longhorn/longhorn/issues/3070</a></p>
<p>Steps:
1. Create a volume and PV/PVC.
2. Create a deployment with 1 pod having below in command section on node-1
and attach to the volume.
command:
- "/bin/sh"
- "-ec"
- |
touch /data/test
tail -f /data/test
3. Wait for the pod to become healthy.
4. Write small(100MB) data.
5. Kill the instance-manager-e on node-1.
6. Wait for the instance-manager-e pod to become healthy.
7. Wait for pod to get terminated and recreated.
8. Read and write in the pod to verify the pod is accessible.</p></div>
</dd>
<dt id="tests.test_ha.test_replica_failure_during_attaching"><code class="name flex">
<span>def <span class="ident">test_replica_failure_during_attaching</span></span>(<span>settings_reset, client, core_api, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_replica_failure_during_attaching(settings_reset, client, core_api, volume_name):  # NOQA
    &#34;&#34;&#34;
    Steps:
    1. Set a short interval for setting replica-replenishment-wait-interval.
    2. Disable the setting soft-node-anti-affinity.
    3. Create volume1 with 1 replica. and attach it to the host node.
    4. Mount volume1 to a new mount point. then use it as an extra node disk.
    5. Disable the scheduling for the default disk of the host node,
       and make sure the extra disk is the only available disk on the node.
    6. Create and attach volume2, then write data to volume2.
    7. Detach volume2.
    8. Directly unmount volume1 and remove the related mount point directory.
       --&gt; Verify the extra disk becomes unavailable.
    9. Attach volume2.
       --&gt; Verify volume will be attached with state Degraded.
    10. Wait for the replenishment interval.
        --&gt; Verify a new replica cannot be scheduled.
    11. Enable the default disk for the host node.
    12. Wait for volume2 becoming Healthy.
    13. Verify data content and r/w capability for volume2.
    &#34;&#34;&#34;

    replenish_wait_setting = \
        client.by_id_setting(SETTING_REPLICA_REPLENISHMENT_WAIT_INTERVAL)
    client.update(replenish_wait_setting, value=&#39;10&#39;)

    replica_node_soft_anti_affinity_setting = \
        client.by_id_setting(SETTING_REPLICA_NODE_SOFT_ANTI_AFFINITY)
    client.update(replica_node_soft_anti_affinity_setting, value=&#34;false&#34;)

    volume_name_1 = volume_name
    host_id = get_self_host_id()
    node = client.by_id_node(host_id)

    extra_disk_path = create_host_disk(client, volume_name_1, str(3 * Gi),
                                       host_id)
    extra_disk = {&#34;path&#34;: extra_disk_path, &#34;allowScheduling&#34;: True}

    update_disks = get_update_disks(node.disks)
    default_disk_name = next(iter(update_disks))
    update_disks[&#34;extra-disk&#34;] = extra_disk
    update_disks[default_disk_name].allowScheduling = False

    node = update_node_disks(client, node.name, disks=update_disks)
    node = common.wait_for_disk_update(client, node.name, len(update_disks))

    volume_name_2 = volume_name + &#39;-2&#39;
    volume_2 = create_and_check_volume(client, volume_name_2,
                                       num_of_replicas=3,
                                       size=str(1 * Gi))
    volume_2.attach(hostId=host_id)
    volume_2 = wait_for_volume_healthy(client, volume_name_2)
    write_volume_random_data(volume_2)
    volume_2.detach()
    wait_for_volume_detached(client, volume_name_2)

    # unmount the disk
    mount_path = os.path.join(DIRECTORY_PATH, volume_name_1)
    common.umount_disk(mount_path)
    cmd = [&#39;rm&#39;, &#39;-r&#39;, mount_path]
    subprocess.check_call(cmd)

    volume_2 = client.by_id_volume(volume_name_2)
    volume_2.attach(hostId=host_id)
    common.wait_for_volume_status(client, volume_name_2,
                                  VOLUME_FIELD_ROBUSTNESS,
                                  VOLUME_ROBUSTNESS_DEGRADED)

    time.sleep(10)
    try:
        wait_for_volume_replica_count(client, volume_name_2, 4)
        raise AssertionError(&#34;No new replica should be created&#34;)
    except AssertionError:
        pass

    wait_scheduling_failure(client, volume_name_2)

    update_disks[default_disk_name].allowScheduling = True
    update_disks[&#34;extra-disk&#34;][&#34;allowScheduling&#34;] = False

    node = update_node_disks(client, node.name, disks=update_disks)
    common.wait_for_disk_update(client, node.name, len(update_disks))

    common.wait_for_volume_status(client, volume_name_2,
                                  VOLUME_FIELD_ROBUSTNESS,
                                  VOLUME_ROBUSTNESS_HEALTHY)

    volume_2 = client.by_id_volume(volume_name_2)
    write_volume_random_data(volume_2)

    del update_disks[&#34;extra-disk&#34;]
    update_node_disks(client, node.name, disks=update_disks)
    common.wait_for_disk_update(client, node.name, 1)</code></pre>
</details>
<div class="desc"><p>Steps:
1. Set a short interval for setting replica-replenishment-wait-interval.
2. Disable the setting soft-node-anti-affinity.
3. Create volume1 with 1 replica. and attach it to the host node.
4. Mount volume1 to a new mount point. then use it as an extra node disk.
5. Disable the scheduling for the default disk of the host node,
and make sure the extra disk is the only available disk on the node.
6. Create and attach volume2, then write data to volume2.
7. Detach volume2.
8. Directly unmount volume1 and remove the related mount point directory.
&ndash;&gt; Verify the extra disk becomes unavailable.
9. Attach volume2.
&ndash;&gt; Verify volume will be attached with state Degraded.
10. Wait for the replenishment interval.
&ndash;&gt; Verify a new replica cannot be scheduled.
11. Enable the default disk for the host node.
12. Wait for volume2 becoming Healthy.
13. Verify data content and r/w capability for volume2.</p></div>
</dd>
<dt id="tests.test_ha.test_replica_should_not_be_created_when_no_suitable_node_found"><code class="name flex">
<span>def <span class="ident">test_replica_should_not_be_created_when_no_suitable_node_found</span></span>(<span>client, volume_name, settings_reset)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_replica_should_not_be_created_when_no_suitable_node_found(client, volume_name, settings_reset): # NOQA
    &#34;&#34;&#34;
    Test replica should not be created when no suitable node is found.

    1. Make sure &#39;Replica Node Level Soft Anti-Affinity&#39; is disabled.
    2. Create a volume with 3 replicas.
    3. Attach the volume to a node and write some data to it and
    save the checksum.
    4. Increase the volume replica number to 4.
    5. No Replica should be created.
    6. Volume should show failed to schedule.
    7. Decrease the volume replica number to 3.
    8. Volume should be healthy.
    9. Check the data in the volume and make sure it&#39;s same as the checksum.
    &#34;&#34;&#34;
    replica_node_soft_anti_affinity_setting = \
        client.by_id_setting(SETTING_REPLICA_NODE_SOFT_ANTI_AFFINITY)
    try:
        client.update(replica_node_soft_anti_affinity_setting,
                      value=&#34;false&#34;)
    except Exception as e:
        print(&#34;\nException when update &#34;
              &#34;Replica Node Level Soft Anti-Affinity setting&#34;,
              replica_node_soft_anti_affinity_setting)
        print(e)

    host_id = get_self_host_id()
    volume = create_and_check_volume(client, volume_name, num_of_replicas=3)

    volume = volume.attach(hostId=host_id)
    volume = wait_for_volume_healthy(client, volume_name)
    data = write_volume_random_data(volume)
    volume = volume.updateReplicaCount(replicaCount=4)
    try:
        wait_for_volume_replica_count(client, volume_name, 4)
        raise AssertionError(&#34;Replica should not be created&#34;)
    except AssertionError:
        pass

    volume = wait_for_volume_degraded(client, volume_name)

    assert volume.conditions.Scheduled.status == &#34;False&#34;
    assert volume.conditions.Scheduled.reason == &#34;ReplicaSchedulingFailure&#34;

    volume = volume.updateReplicaCount(replicaCount=3)
    wait_for_volume_replica_count(client, volume_name, 3)

    volume = client.by_id_volume(volume_name)
    wait_for_volume_healthy(client, volume_name)

    check_volume_data(volume, data)</code></pre>
</details>
<div class="desc"><p>Test replica should not be created when no suitable node is found.</p>
<ol>
<li>Make sure 'Replica Node Level Soft Anti-Affinity' is disabled.</li>
<li>Create a volume with 3 replicas.</li>
<li>Attach the volume to a node and write some data to it and
save the checksum.</li>
<li>Increase the volume replica number to 4.</li>
<li>No Replica should be created.</li>
<li>Volume should show failed to schedule.</li>
<li>Decrease the volume replica number to 3.</li>
<li>Volume should be healthy.</li>
<li>Check the data in the volume and make sure it's same as the checksum.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_restore_volume_with_invalid_backupstore"><code class="name flex">
<span>def <span class="ident">test_restore_volume_with_invalid_backupstore</span></span>(<span>client, volume_name, backupstore_s3)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
@pytest.mark.skipif(&#39;s3&#39; not in BACKUPSTORE, reason=&#39;This test is only applicable for s3&#39;)  # NOQA
def test_restore_volume_with_invalid_backupstore(client, volume_name, backupstore_s3): # NOQA
    &#34;&#34;&#34;
    [HA] Test if the invalid backup target will lead to to volume restore.

    1. Enable auto-salvage.
    2. Set a S3 backupstore. (Cannot use NFS server here before fixing #1295)
    3. Create a volume then a backup.
    4. Invalidate the target URL.
       (e.g.: s3://backupbucket-invalid@us-east-1/backupstore-invalid)
    5. Restore a volume from the backup should return error.
       (The fromBackup fields of the volume create API should consist of
       the invalid target URL and the valid backup volume info)
    6. Check restore volume not created.
    &#34;&#34;&#34;
    auto_salvage_setting = client.by_id_setting(SETTING_AUTO_SALVAGE)
    assert auto_salvage_setting.name == SETTING_AUTO_SALVAGE
    assert auto_salvage_setting.value == &#34;true&#34;

    volume = create_and_check_volume(client, volume_name)
    host_id = get_self_host_id()
    volume.attach(hostId=host_id)
    volume = wait_for_volume_healthy(client, volume_name)

    _, b, _, _ = create_backup(client, volume_name)

    res_name = &#34;res-&#34; + volume_name
    invalid_backup_target_url = \
        &#34;s3://backupbucket-invalid@us-east-1/backupstore-invalid&#34;

    try:
        backup_target_setting = client.by_id_setting(SETTING_BACKUP_TARGET)
        backup_target_setting = client.update(backup_target_setting,
                                              value=invalid_backup_target_url)
    except Exception as e:
        if SETTING_BACKUP_TARGET_NOT_SUPPORTED in e.error.message:
            set_backupstore_url(client, invalid_backup_target_url)
        else:
            raise e

    # make fromBackup URL consistent to the the invalid target URL
    url = invalid_backup_target_url + b.url.split(&#34;?&#34;)[1]
    with pytest.raises(Exception) as e:
        client.create_volume(name=res_name,
                             fromBackup=url)
    assert &#34;unable to create volume&#34; in str(e.value)

    volumes = client.list_volume()
    for v in volumes:
        assert v.name != res_name</code></pre>
</details>
<div class="desc"><p>[HA] Test if the invalid backup target will lead to to volume restore.</p>
<ol>
<li>Enable auto-salvage.</li>
<li>Set a S3 backupstore. (Cannot use NFS server here before fixing #1295)</li>
<li>Create a volume then a backup.</li>
<li>Invalidate the target URL.
(e.g.: s3://backupbucket-invalid@us-east-1/backupstore-invalid)</li>
<li>Restore a volume from the backup should return error.
(The fromBackup fields of the volume create API should consist of
the invalid target URL and the valid backup volume info)</li>
<li>Check restore volume not created.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_retain_potentially_useful_replicas_in_autosalvage_loop"><code class="name flex">
<span>def <span class="ident">test_retain_potentially_useful_replicas_in_autosalvage_loop</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.skip(reason=&#34;TODO&#34;)  # NOQA
def test_retain_potentially_useful_replicas_in_autosalvage_loop():
    &#34;&#34;&#34;
    Related issue:
    https://github.com/longhorn/longhorn/issues/7425

    Related manual test steps:
    https://github.com/longhorn/longhorn-manager/pull/2432#issuecomment-1894675916

    Steps:
    1. Create a volume with numberOfReplicas=2 and staleReplicaTimeout=1.
       Consider its two replicas ReplicaA and ReplicaB.
    2. Attach the volume to a node.
    3. Write data to the volume.
    4. Exec into the instance-manager for ReplicaB and delete all .img.meta
       files. This makes it impossible to restart ReplicaB successfully.
    5. Cordon the node for Replica A. This makes it unavailable for
       autosalvage.
    6. Crash the instance-managers for both ReplicaA and ReplicaB.
    7. Wait one minute and fifteen seconds. This is longer than
       staleReplicaTimeout.
    8. Confirm the volume is not healthy.
    9. Confirm ReplicaA was not deleted.
    10. Delete ReplicaB.
    11. Wait for the volume to become healthy.
    12. Verify the data.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Related issue:
<a href="https://github.com/longhorn/longhorn/issues/7425">https://github.com/longhorn/longhorn/issues/7425</a></p>
<p>Related manual test steps:
<a href="https://github.com/longhorn/longhorn-manager/pull/2432#issuecomment-1894675916">https://github.com/longhorn/longhorn-manager/pull/2432#issuecomment-1894675916</a></p>
<p>Steps:
1. Create a volume with numberOfReplicas=2 and staleReplicaTimeout=1.
Consider its two replicas ReplicaA and ReplicaB.
2. Attach the volume to a node.
3. Write data to the volume.
4. Exec into the instance-manager for ReplicaB and delete all .img.meta
files. This makes it impossible to restart ReplicaB successfully.
5. Cordon the node for Replica A. This makes it unavailable for
autosalvage.
6. Crash the instance-managers for both ReplicaA and ReplicaB.
7. Wait one minute and fifteen seconds. This is longer than
staleReplicaTimeout.
8. Confirm the volume is not healthy.
9. Confirm ReplicaA was not deleted.
10. Delete ReplicaB.
11. Wait for the volume to become healthy.
12. Verify the data.</p></div>
</dd>
<dt id="tests.test_ha.test_reuse_failed_replica"><code class="name flex">
<span>def <span class="ident">test_reuse_failed_replica</span></span>(<span>client, core_api, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_reuse_failed_replica(client, core_api, volume_name): # NOQA
    &#34;&#34;&#34;
    Steps:
    1. Set a long wait interval for
       setting `replica-replenishment-wait-interval`.
    2. Disable the setting soft node anti-affinity.
    3. Create and attach a volume. Then write data to the volume.
    4. Disable the scheduling for a node.
    5. Mess up the data of a random snapshot or the volume head for a replica.
       Then crash the replica on the node.
       --&gt; Verify Longhorn won&#39;t create a new replica on the node
           for the volume.
    6. Update setting `replica-replenishment-wait-interval` to
       a small value.
    7. Verify no new replica will be created.
    8. Verify volume replica scheduling should fail.
    9. Update setting `replica-replenishment-wait-interval` to a large value.
    10. Enable the scheduling for the node.
    11. Verify the failed replica (in step 5) will be reused.
    12. Verify the volume r/w still works fine.
    &#34;&#34;&#34;
    long_wait = 60*60
    short_wait = 3

    replenish_wait_setting = \
        client.by_id_setting(SETTING_REPLICA_REPLENISHMENT_WAIT_INTERVAL)
    client.update(replenish_wait_setting, value=str(long_wait))

    replica_node_soft_anti_affinity_setting = \
        client.by_id_setting(SETTING_REPLICA_NODE_SOFT_ANTI_AFFINITY)
    client.update(replica_node_soft_anti_affinity_setting, value=&#34;false&#34;)

    vol = create_and_check_volume(client, volume_name)
    host_id = get_self_host_id()
    vol = vol.attach(hostId=host_id)
    vol = wait_for_volume_healthy(client, volume_name)
    data = {
        &#39;pos&#39;: 0,
        &#39;content&#39;: generate_random_data(16*Ki),
    }
    common.write_volume_data(vol, data)

    current_host = client.by_id_node(id=host_id)
    client.update(current_host, allowScheduling=False)

    vol = client.by_id_volume(volume_name)
    assert len(vol.replicas) == 3
    other_replicas = []
    for r in vol.replicas:
        if r[&#34;hostId&#34;] == current_host.name:
            replica_1 = r
        else:
            other_replicas.append(r)
    replica_2, replica_3 = other_replicas

    for filenames in os.listdir(replica_1.dataPath):
        if filenames.endswith(&#34;.img&#34;):
            with open(os.path.join(replica_1.dataPath, filenames), &#39;w&#39;) as f:
                f.write(&#34;Longhorn is the best!&#34;)

    crash_replica_processes(client, core_api, volume_name,
                            replicas=[replica_1],
                            wait_to_fail=False)

    # We need to wait for a minute to very that
    # Longhorn doesn&#39;t create a new replica
    for i in range(SMALL_RETRY_COUNTS):
        vol = client.by_id_volume(volume_name)
        current_replica_names = set([r.name for r in vol.replicas])
        assert current_replica_names == \
               {replica_1.name, replica_2.name, replica_3.name}
        time.sleep(RETRY_INTERVAL_LONG)

    replenish_wait_setting = \
        client.by_id_setting(SETTING_REPLICA_REPLENISHMENT_WAIT_INTERVAL)
    client.update(replenish_wait_setting, value=str(short_wait))

    try:
        common.wait_for_volume_replica_count(client, volume_name,
                                             len(vol.replicas)+1)
        raise Exception(&#34;No new replica should be created&#34;)
    except AssertionError:
        pass

    wait_scheduling_failure(client, volume_name)

    replenish_wait_setting = \
        client.by_id_setting(SETTING_REPLICA_REPLENISHMENT_WAIT_INTERVAL)
    client.update(replenish_wait_setting, value=str(long_wait))

    current_host = client.by_id_node(id=host_id)
    client.update(current_host, allowScheduling=True)

    vol = wait_for_volume_healthy(client, volume_name)
    current_replica_names = set([r.name for r in vol.replicas])
    assert current_replica_names == \
           {replica_1.name, replica_2.name, replica_3.name}
    data = common.write_volume_data(vol, data)
    check_volume_data(vol, data)</code></pre>
</details>
<div class="desc"><p>Steps:
1. Set a long wait interval for
setting <code>replica-replenishment-wait-interval</code>.
2. Disable the setting soft node anti-affinity.
3. Create and attach a volume. Then write data to the volume.
4. Disable the scheduling for a node.
5. Mess up the data of a random snapshot or the volume head for a replica.
Then crash the replica on the node.
&ndash;&gt; Verify Longhorn won't create a new replica on the node
for the volume.
6. Update setting <code>replica-replenishment-wait-interval</code> to
a small value.
7. Verify no new replica will be created.
8. Verify volume replica scheduling should fail.
9. Update setting <code>replica-replenishment-wait-interval</code> to a large value.
10. Enable the scheduling for the node.
11. Verify the failed replica (in step 5) will be reused.
12. Verify the volume r/w still works fine.</p></div>
</dd>
<dt id="tests.test_ha.test_reuse_failed_replica_with_scheduling_check"><code class="name flex">
<span>def <span class="ident">test_reuse_failed_replica_with_scheduling_check</span></span>(<span>client, core_api, volume_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_reuse_failed_replica_with_scheduling_check(client, core_api, volume_name): # NOQA
    &#34;&#34;&#34;
    Steps:
    1. Set a long wait interval for
       setting `replica-replenishment-wait-interval`.
    2. Disable the setting soft node anti-affinity.
    3. Add tags for all nodes and disks.
    4. Create and attach a volume with node and disk selectors.
       Then write data to the volume.
    5. Disable the scheduling for the 2 nodes (node1 and node2).
    6. Crash the replicas on the node1 and node2.
       --&gt; Verify Longhorn won&#39;t create new replicas on the nodes.
    7. Remove tags for node1 and the related disks.
    8. Enable the scheduling for node1 and node2.
    9. Verify the only failed replica on node2 is reused.
    10. Add the tags back for node1 and the related disks.
    11. Verify the failed replica on node1 is reused.
    12. Verify the volume r/w still works fine.
    &#34;&#34;&#34;
    long_wait = 60*60
    replenish_wait_setting = \
        client.by_id_setting(SETTING_REPLICA_REPLENISHMENT_WAIT_INTERVAL)
    client.update(replenish_wait_setting, value=str(long_wait))

    replica_node_soft_anti_affinity_setting = \
        client.by_id_setting(SETTING_REPLICA_NODE_SOFT_ANTI_AFFINITY)
    client.update(replica_node_soft_anti_affinity_setting, value=&#34;false&#34;)

    nodes = client.list_node()
    tags = [&#34;avail&#34;]
    for node in nodes:
        set_tags_for_node_and_its_disks(client, node, tags)

    client.create_volume(name=volume_name, size=SIZE, numberOfReplicas=3,
                         diskSelector=tags, nodeSelector=tags)
    vol = wait_for_volume_detached(client, volume_name)
    assert vol.diskSelector == tags
    assert vol.nodeSelector == tags
    vol.attach(hostId=get_self_host_id())
    vol = wait_for_volume_healthy(client, volume_name)
    data = {
        &#39;pos&#39;: 0,
        &#39;content&#39;: generate_random_data(16*Ki),
    }
    common.write_volume_data(vol, data)

    nodes = client.list_node()
    assert len(nodes) == 3
    node_1, node_2, node_3 = nodes
    set_node_scheduling(client, node_1, allowScheduling=False)
    set_node_scheduling(client, node_2, allowScheduling=False)

    vol = client.by_id_volume(volume_name)
    replica_1, replica_2, replica_3 = None, None, None
    for r in vol.replicas:
        if r.hostId == node_1.name:
            replica_1 = r
        elif r.hostId == node_2.name:
            replica_2 = r
        elif r.hostId == node_3.name:
            replica_3 = r
    assert replica_1 is not None and \
           replica_2 is not None and \
           replica_3 is not None

    crash_replica_processes(client, core_api,
                            volume_name,
                            replicas=[replica_1, replica_2],
                            wait_to_fail=False)

    # We need to wait for a minute to very that
    # Longhorn doesn&#39;t create a new replica
    for i in range(SMALL_RETRY_COUNTS):
        vol = client.by_id_volume(volume_name)
        current_replica_names = set([r.name for r in vol.replicas])
        assert current_replica_names == \
               {replica_1.name, replica_2.name, replica_3.name}
        time.sleep(RETRY_INTERVAL_LONG)

    node_1 = set_tags_for_node_and_its_disks(client, node_1, [])

    set_node_scheduling(client, node_1, allowScheduling=True)
    set_node_scheduling(client, node_2, allowScheduling=True)

    # Wait for rebuilding to finish
    # It should take less than 1 minute since the replica is small
    time.sleep(60)

    vol = client.by_id_volume(volume_name)
    for r in vol.replicas:
        if r.name == replica_1.name:
            assert r.failedAt != &#34;&#34; and r.running is False
        else:
            assert r.failedAt == &#34;&#34; and r.running is True

    node_1 = set_tags_for_node_and_its_disks(client, node_1, tags)

    vol = wait_for_volume_healthy(client, volume_name)
    current_replica_names = set([r.name for r in vol.replicas])
    assert current_replica_names == \
           {replica_1.name, replica_2.name, replica_3.name}
    data = common.write_volume_data(vol, data)
    check_volume_data(vol, data)</code></pre>
</details>
<div class="desc"><p>Steps:
1. Set a long wait interval for
setting <code>replica-replenishment-wait-interval</code>.
2. Disable the setting soft node anti-affinity.
3. Add tags for all nodes and disks.
4. Create and attach a volume with node and disk selectors.
Then write data to the volume.
5. Disable the scheduling for the 2 nodes (node1 and node2).
6. Crash the replicas on the node1 and node2.
&ndash;&gt; Verify Longhorn won't create new replicas on the nodes.
7. Remove tags for node1 and the related disks.
8. Enable the scheduling for node1 and node2.
9. Verify the only failed replica on node2 is reused.
10. Add the tags back for node1 and the related disks.
11. Verify the failed replica on node1 is reused.
12. Verify the volume r/w still works fine.</p></div>
</dd>
<dt id="tests.test_ha.test_salvage_auto_crash_all_replicas"><code class="name flex">
<span>def <span class="ident">test_salvage_auto_crash_all_replicas</span></span>(<span>client, core_api, storage_class, sts_name, statefulset)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_salvage_auto_crash_all_replicas(client, core_api, storage_class, sts_name, statefulset):  # NOQA
    &#34;&#34;&#34;
    [HA] Test automatic salvage feature by crashing all the replicas

    Case #1: crash all replicas
    1. Create StorageClass and StatefulSet.
    2. Write random data to the pod and get the md5sum.
    3. Run `sync` command inside the pod to make sure data flush to the volume.
    4. Crash all replica processes using SIGTERM.
    5. Wait for volume to `faulted`, then `healthy`.
    6. Wait for K8s to terminate the pod and statefulset to bring pod to
       `Pending`, then `Running`.
    7. Check volume path exist in the pod.
    8. Check md5sum of the data in the pod.
    Case #2: crash one replica and then crash all replicas
    9. Crash one of the replica.
    10. Try to wait for rebuild start and the rebuilding replica running.
    11. Crash all the replicas.
    12. Make sure volume and pod recovers.
    13. Check md5sum of the data in the pod.

    FIXME: Step 5 is only a intermediate state, maybe no way to get it for sure
    &#34;&#34;&#34;

    # Case #1
    vol_name, pod_name, md5sum = common.prepare_statefulset_with_data_in_mb(
        client, core_api, statefulset, sts_name, storage_class)
    crash_replica_processes(client, core_api, vol_name)
    wait_pod_for_remount_request(client, core_api, vol_name, pod_name, md5sum)

    # Case #2
    volume = client.by_id_volume(vol_name)
    replica0 = volume.replicas[0]

    crash_replica_processes(client, core_api, vol_name, [replica0])

    volume = wait_for_volume_healthy(client, vol_name)
    replicas = []
    for r in volume.replicas:
        if r.running is True:
            replicas.append(r)

    crash_replica_processes(client, core_api, vol_name, replicas)

    wait_pod_for_remount_request(client, core_api, vol_name, pod_name, md5sum)</code></pre>
</details>
<div class="desc"><p>[HA] Test automatic salvage feature by crashing all the replicas</p>
<p>Case #1: crash all replicas
1. Create StorageClass and StatefulSet.
2. Write random data to the pod and get the md5sum.
3. Run <code>sync</code> command inside the pod to make sure data flush to the volume.
4. Crash all replica processes using SIGTERM.
5. Wait for volume to <code>faulted</code>, then <code>healthy</code>.
6. Wait for K8s to terminate the pod and statefulset to bring pod to
<code>Pending</code>, then <code>Running</code>.
7. Check volume path exist in the pod.
8. Check md5sum of the data in the pod.
Case #2: crash one replica and then crash all replicas
9. Crash one of the replica.
10. Try to wait for rebuild start and the rebuilding replica running.
11. Crash all the replicas.
12. Make sure volume and pod recovers.
13. Check md5sum of the data in the pod.</p>
<p>FIXME: Step 5 is only a intermediate state, maybe no way to get it for sure</p></div>
</dd>
<dt id="tests.test_ha.test_single_replica_failed_during_engine_start"><code class="name flex">
<span>def <span class="ident">test_single_replica_failed_during_engine_start</span></span>(<span>client, core_api, volume_name, csi_pv, pvc, pod)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.coretest  # NOQA
def test_single_replica_failed_during_engine_start(client, core_api, volume_name, csi_pv, pvc, pod):  # NOQA
    &#34;&#34;&#34;
    Test if the volume still works fine when there is
    an invalid replica/backend in the engine starting phase.

    Prerequisite:
    Setting &#34;replica-replenishment-wait-interval&#34; is 0

    1. Create a pod using Longhorn volume.
    2. Write some data to the volume then get the md5sum.
    3. Create a snapshot.
    4. Repeat step2 and step3 for 3 times then there should be 3 snapshots.
    5. Randomly pick up a replica and
       manually messing up the snapshot meta file.
    6. Delete the pod and wait for the volume detached.
    7. Recreate the pod and wait for the volume attached.
    8. Check if the volume is Degraded and
       if the chosen replica is ERR once the volume attached.
    9. Wait for volume rebuild and volume becoming Healthy.
    10. Check volume data.
    11. Check if the volume still works fine by
        r/w data and creating/removing snapshots.
    &#34;&#34;&#34;
    replenish_wait_setting = \
        client.by_id_setting(SETTING_REPLICA_REPLENISHMENT_WAIT_INTERVAL)
    client.update(replenish_wait_setting, value=&#34;0&#34;)

    pv_name = &#34;pv-&#34; + volume_name
    pvc_name = &#34;pvc-&#34; + volume_name
    pod_name = &#34;pod-&#34; + volume_name
    volume_size = str(1 * Gi)

    csi_pv[&#39;metadata&#39;][&#39;name&#39;] = pv_name
    csi_pv[&#39;spec&#39;][&#39;csi&#39;][&#39;volumeHandle&#39;] = volume_name
    csi_pv[&#39;spec&#39;][&#39;capacity&#39;][&#39;storage&#39;] = volume_size
    pvc[&#39;metadata&#39;][&#39;name&#39;] = pvc_name
    pvc[&#39;spec&#39;][&#39;volumeName&#39;] = pv_name
    pvc[&#39;spec&#39;][&#39;resources&#39;][&#39;requests&#39;][&#39;storage&#39;] = volume_size
    pvc[&#39;spec&#39;][&#39;storageClassName&#39;] = &#39;&#39;

    create_and_check_volume(client, volume_name, size=volume_size)
    core_api.create_persistent_volume(csi_pv)
    core_api.create_namespaced_persistent_volume_claim(
        body=pvc, namespace=&#39;default&#39;)

    pod[&#39;metadata&#39;][&#39;name&#39;] = pod_name
    pod[&#39;spec&#39;][&#39;volumes&#39;] = [{
        &#39;name&#39;: pod[&#39;spec&#39;][&#39;containers&#39;][0][&#39;volumeMounts&#39;][0][&#39;name&#39;],
        &#39;persistentVolumeClaim&#39;: {
            &#39;claimName&#39;: pvc_name,
        },
    }]

    create_and_wait_pod(core_api, pod)
    wait_for_volume_healthy(client, volume_name)

    volume = client.by_id_volume(volume_name)

    data_path1 = &#34;/data/file1&#34;
    write_pod_volume_random_data(core_api, pod_name,
                                 data_path1, DATA_SIZE_IN_MB_1)
    data_md5sum1 = get_pod_data_md5sum(core_api, pod_name, data_path1)
    snap1 = create_snapshot(client, volume_name)

    data_path2 = &#34;/data/file2&#34;
    write_pod_volume_random_data(core_api, pod_name,
                                 data_path2, DATA_SIZE_IN_MB_1)
    data_md5sum2 = get_pod_data_md5sum(core_api, pod_name, data_path2)
    snap2 = create_snapshot(client, volume_name)

    data_path3 = &#34;/data/file3&#34;
    write_pod_volume_random_data(core_api, pod_name,
                                 data_path3, DATA_SIZE_IN_MB_1)
    data_md5sum3 = get_pod_data_md5sum(core_api, pod_name, data_path3)
    snap3 = create_snapshot(client, volume_name)

    volume = client.by_id_volume(volume_name)
    host_id = get_self_host_id()

    for replica in volume.replicas:
        if replica.hostId == host_id:
            break

    replica_data_path = replica.dataPath
    replica_name = replica.name
    snap2_meta_file = replica_data_path + \
        &#34;/volume-snap-&#34; + \
        snap2.name + &#34;.img.meta&#34;

    command = [&#34;dd&#34;, &#34;if=/dev/zero&#34;,
               &#34;of=&#34;+snap2_meta_file,
               &#34;count=&#34; + str(100)]
    subprocess.check_call(command)

    delete_and_wait_pod(core_api, pod_name)
    wait_for_volume_detached(client, volume_name)

    create_and_wait_pod(core_api, pod)
    wait_for_volume_degraded(client, volume_name)
    wait_for_replica_failed(client, volume_name, replica_name)

    wait_for_volume_healthy(client, volume_name)

    res_data_md5sum1 = get_pod_data_md5sum(core_api, pod_name, data_path1)
    assert data_md5sum1 == res_data_md5sum1

    res_data_md5sum2 = get_pod_data_md5sum(core_api, pod_name, data_path2)
    assert data_md5sum2 == res_data_md5sum2

    res_data_md5sum3 = get_pod_data_md5sum(core_api, pod_name, data_path3)
    assert data_md5sum3 == res_data_md5sum3

    data_path4 = &#34;/data/file4&#34;
    write_pod_volume_random_data(core_api, pod_name,
                                 data_path4, DATA_SIZE_IN_MB_1)
    data_md5sum4 = get_pod_data_md5sum(core_api, pod_name, data_path4)

    res_data_md5sum4 = get_pod_data_md5sum(core_api, pod_name, data_path4)
    assert data_md5sum4 == res_data_md5sum4

    snap4 = create_snapshot(client, volume_name)

    snapshots = volume.snapshotList()
    for snap in snapshots:
        if snap.usercreated is False and snap.name != &#34;volume-head&#34;:
            system_snap = snap
            break

    snapMap = {}
    for snap in snapshots:
        snapMap[snap.name] = snap

    assert snapMap[snap1.name].name == snap1.name
    assert snapMap[snap1.name].removed is False
    assert snapMap[snap2.name].name == snap2.name
    assert snapMap[snap2.name].parent == snap1.name
    assert snapMap[snap2.name].removed is False
    assert snapMap[snap3.name].name == snap3.name
    assert snapMap[snap3.name].parent == snap2.name
    assert snapMap[snap3.name].removed is False
    assert snapMap[snap4.name].name == snap4.name
    assert snapMap[snap4.name].parent == system_snap.name
    assert snapMap[snap4.name].removed is False

    volume.snapshotDelete(name=snap3.name)

    snapshots = volume.snapshotList(volume=volume_name)
    snapMap = {}
    for snap in snapshots:
        snapMap[snap.name] = snap

    assert snapMap[snap1.name].name == snap1.name
    assert snapMap[snap1.name].removed is False
    assert snapMap[snap2.name].name == snap2.name
    assert snapMap[snap2.name].parent == snap1.name
    assert snapMap[snap2.name].removed is False
    assert snapMap[snap3.name].name == snap3.name
    assert snapMap[snap3.name].parent == snap2.name
    assert snapMap[snap3.name].removed is True
    assert snapMap[snap4.name].name == snap4.name
    assert snapMap[snap4.name].parent == system_snap.name
    assert len(snapMap[snap4.name].children) == 1
    assert &#34;volume-head&#34; in snapMap[snap4.name].children.keys()
    assert snapMap[snap4.name].removed is False</code></pre>
</details>
<div class="desc"><p>Test if the volume still works fine when there is
an invalid replica/backend in the engine starting phase.</p>
<p>Prerequisite:
Setting "replica-replenishment-wait-interval" is 0</p>
<ol>
<li>Create a pod using Longhorn volume.</li>
<li>Write some data to the volume then get the md5sum.</li>
<li>Create a snapshot.</li>
<li>Repeat step2 and step3 for 3 times then there should be 3 snapshots.</li>
<li>Randomly pick up a replica and
manually messing up the snapshot meta file.</li>
<li>Delete the pod and wait for the volume detached.</li>
<li>Recreate the pod and wait for the volume attached.</li>
<li>Check if the volume is Degraded and
if the chosen replica is ERR once the volume attached.</li>
<li>Wait for volume rebuild and volume becoming Healthy.</li>
<li>Check volume data.</li>
<li>Check if the volume still works fine by
r/w data and creating/removing snapshots.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_single_replica_restore_failure"><code class="name flex">
<span>def <span class="ident">test_single_replica_restore_failure</span></span>(<span>set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_single_replica_restore_failure(set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make):  # NOQA
    &#34;&#34;&#34;
    [HA] Test if one replica restore failure will lead to the restore volume
    becoming Degraded, and if the restore volume is still usable after
    the failure.

    This is similar to test_rebuild_with_restoration and
    test_single_replica_unschedulable_restore_failure. In this version, a
    replica is crashed. We expect the crashed replica to be rebuilt and the
    restore to complete.

    1. Setup a random backupstore.
    2. Do cleanup for the backupstore.
    3. Create a pod with a volume and wait for pod to start.
    4. Write data to the pod volume and get the md5sum.
    5. Create a backup for the volume.
    6. Restore a volume from the backup.
    7. Wait for the volume restore start.
    8. Crash one replica during the restoration.
    9. Wait for the restoration complete and the volume detached.
    10. Check if the replica is rebuilt.
    11. Create PV/PVC/Pod for the restored volume and wait for the pod start.
    12. Check if the restored volume is state `Healthy`
        after the attachment.
    13. Check md5sum of the data in the restored volume.
    14. Do cleanup.
    &#34;&#34;&#34;
    restore_with_replica_failure(client, core_api, volume_name, csi_pv, pvc,
                                 pod_make, False, False,
                                 REPLICA_FAILURE_MODE_CRASH)</code></pre>
</details>
<div class="desc"><p>[HA] Test if one replica restore failure will lead to the restore volume
becoming Degraded, and if the restore volume is still usable after
the failure.</p>
<p>This is similar to test_rebuild_with_restoration and
test_single_replica_unschedulable_restore_failure. In this version, a
replica is crashed. We expect the crashed replica to be rebuilt and the
restore to complete.</p>
<ol>
<li>Setup a random backupstore.</li>
<li>Do cleanup for the backupstore.</li>
<li>Create a pod with a volume and wait for pod to start.</li>
<li>Write data to the pod volume and get the md5sum.</li>
<li>Create a backup for the volume.</li>
<li>Restore a volume from the backup.</li>
<li>Wait for the volume restore start.</li>
<li>Crash one replica during the restoration.</li>
<li>Wait for the restoration complete and the volume detached.</li>
<li>Check if the replica is rebuilt.</li>
<li>Create PV/PVC/Pod for the restored volume and wait for the pod start.</li>
<li>Check if the restored volume is state <code>Healthy</code>
after the attachment.</li>
<li>Check md5sum of the data in the restored volume.</li>
<li>Do cleanup.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_single_replica_unschedulable_restore_failure"><code class="name flex">
<span>def <span class="ident">test_single_replica_unschedulable_restore_failure</span></span>(<span>set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_single_replica_unschedulable_restore_failure(set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make): # NOQA
    &#34;&#34;&#34;
    [HA] Test if the restore can complete if a restoring replica is killed
    while it is ongoing and cannot be recovered.

    This is similar to test_rebuild_with_restoration and
    test_single_replica_restore_failure. In this version, a replica is crashed
    and not allowed to recover. However, we enable
    allow-volume-creation-with-degraded-availability, so we expect the restore
    to complete anyway.

    1. Setup a random backupstore.
    2. Do cleanup for the backupstore.
    3. Enable allow-volume-creation-with-degraded-availability (to allow
       restoration to complete without all replicas).
    4. Create a pod with a volume and wait for pod to start.
    5. Write data to the pod volume and get the md5sum.
    6. Create a backup for the volume.
    7. Restore a volume from the backup.
    8. Wait for the volume restore start.
    9. Disable replica rebuilding (to ensure the killed replica cannot
       recover).
    10. Crash one replica during the restoration.
    11. Wait for the restoration complete and the volume detached.
    12. Create PV/PVC/Pod for the restored volume and wait for the pod start.
    13. Check if the restored volume is state `Healthy`
        after the attachment.
    14. Check md5sum of the data in the restored volume.
    15. Do cleanup.
    &#34;&#34;&#34;
    restore_with_replica_failure(client, core_api, volume_name, csi_pv, pvc,
                                 pod_make, True, True,
                                 REPLICA_FAILURE_MODE_CRASH)</code></pre>
</details>
<div class="desc"><p>[HA] Test if the restore can complete if a restoring replica is killed
while it is ongoing and cannot be recovered.</p>
<p>This is similar to test_rebuild_with_restoration and
test_single_replica_restore_failure. In this version, a replica is crashed
and not allowed to recover. However, we enable
allow-volume-creation-with-degraded-availability, so we expect the restore
to complete anyway.</p>
<ol>
<li>Setup a random backupstore.</li>
<li>Do cleanup for the backupstore.</li>
<li>Enable allow-volume-creation-with-degraded-availability (to allow
restoration to complete without all replicas).</li>
<li>Create a pod with a volume and wait for pod to start.</li>
<li>Write data to the pod volume and get the md5sum.</li>
<li>Create a backup for the volume.</li>
<li>Restore a volume from the backup.</li>
<li>Wait for the volume restore start.</li>
<li>Disable replica rebuilding (to ensure the killed replica cannot
recover).</li>
<li>Crash one replica during the restoration.</li>
<li>Wait for the restoration complete and the volume detached.</li>
<li>Create PV/PVC/Pod for the restored volume and wait for the pod start.</li>
<li>Check if the restored volume is state <code>Healthy</code>
after the attachment.</li>
<li>Check md5sum of the data in the restored volume.</li>
<li>Do cleanup.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.test_volume_reattach_after_engine_sigkill"><code class="name flex">
<span>def <span class="ident">test_volume_reattach_after_engine_sigkill</span></span>(<span>client, core_api, storage_class, sts_name, statefulset)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.v2_volume_test  # NOQA
def test_volume_reattach_after_engine_sigkill(client, core_api, storage_class, sts_name, statefulset):  # NOQA
    &#34;&#34;&#34;
    [HA] Test if the volume can be reattached after using SIGKILL
    to crash the engine process

    1. Create StorageClass and StatefulSet.
    2. Write random data to the pod and get the md5sum.
    3. Crash the engine process by SIGKILL in the engine manager.
    4. Wait for volume to `faulted`, then `healthy`.
    5. Wait for K8s to terminate the pod and statefulset to bring pod to
       `Pending`, then `Running`.
    6. Check volume path exist in the pod.
    7. Check md5sum of the data in the pod.
    8. Check new data written to the volume is successful.
    &#34;&#34;&#34;
    vol_name, pod_name, md5sum = \
        common.prepare_statefulset_with_data_in_mb(
            client, core_api, statefulset, sts_name, storage_class)

    crash_engine_process_with_sigkill(client, core_api, vol_name)

    wait_pod_for_remount_request(client, core_api, vol_name, pod_name, md5sum)

    write_pod_volume_data(core_api, pod_name, &#39;longhorn-integration-test&#39;,
                          filename=&#39;test2&#39;)
    read_data = read_volume_data(core_api, pod_name, &#39;test2&#39;)

    assert read_data == &#39;longhorn-integration-test&#39;</code></pre>
</details>
<div class="desc"><p>[HA] Test if the volume can be reattached after using SIGKILL
to crash the engine process</p>
<ol>
<li>Create StorageClass and StatefulSet.</li>
<li>Write random data to the pod and get the md5sum.</li>
<li>Crash the engine process by SIGKILL in the engine manager.</li>
<li>Wait for volume to <code>faulted</code>, then <code>healthy</code>.</li>
<li>Wait for K8s to terminate the pod and statefulset to bring pod to
<code>Pending</code>, then <code>Running</code>.</li>
<li>Check volume path exist in the pod.</li>
<li>Check md5sum of the data in the pod.</li>
<li>Check new data written to the volume is successful.</li>
</ol></div>
</dd>
<dt id="tests.test_ha.wait_pod_for_remount_request"><code class="name flex">
<span>def <span class="ident">wait_pod_for_remount_request</span></span>(<span>client, core_api, volume_name, pod_name, original_md5sum, data_path='/data/test')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_pod_for_remount_request(client, core_api, volume_name, pod_name, original_md5sum, data_path=&#34;/data/test&#34;):  # NOQA
    try:
        # this line may fail if the recovery is too quick
        wait_for_volume_faulted(client, volume_name)
    except AssertionError:
        print(&#34;\nException waiting for volume faulted,&#34;
              &#34;could have missed it&#34;)

    wait_for_volume_healthy(client, volume_name)

    try:
        common.wait_for_pod_phase(core_api, pod_name, pod_phase=&#34;Pending&#34;)
    except AssertionError:
        print(&#34;\nException waiting for pod pending,&#34;
              &#34;could have missed it&#34;)
    common.wait_for_pod_phase(core_api, pod_name, pod_phase=&#34;Running&#34;)

    wait_for_pod_remount(core_api, pod_name)

    md5sum = get_pod_data_md5sum(core_api, pod_name, data_path)
    assert md5sum == original_md5sum</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tests" href="index.html">tests</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tests.test_ha.ha_backup_deletion_recovery_test" href="#tests.test_ha.ha_backup_deletion_recovery_test">ha_backup_deletion_recovery_test</a></code></li>
<li><code><a title="tests.test_ha.ha_rebuild_replica_test" href="#tests.test_ha.ha_rebuild_replica_test">ha_rebuild_replica_test</a></code></li>
<li><code><a title="tests.test_ha.ha_salvage_test" href="#tests.test_ha.ha_salvage_test">ha_salvage_test</a></code></li>
<li><code><a title="tests.test_ha.ha_simple_recovery_test" href="#tests.test_ha.ha_simple_recovery_test">ha_simple_recovery_test</a></code></li>
<li><code><a title="tests.test_ha.prepare_engine_not_fully_deployed_environment" href="#tests.test_ha.prepare_engine_not_fully_deployed_environment">prepare_engine_not_fully_deployed_environment</a></code></li>
<li><code><a title="tests.test_ha.prepare_engine_not_fully_deployed_environment_with_volumes" href="#tests.test_ha.prepare_engine_not_fully_deployed_environment_with_volumes">prepare_engine_not_fully_deployed_environment_with_volumes</a></code></li>
<li><code><a title="tests.test_ha.prepare_upgrade_image_not_fully_deployed_environment" href="#tests.test_ha.prepare_upgrade_image_not_fully_deployed_environment">prepare_upgrade_image_not_fully_deployed_environment</a></code></li>
<li><code><a title="tests.test_ha.restore_with_replica_failure" href="#tests.test_ha.restore_with_replica_failure">restore_with_replica_failure</a></code></li>
<li><code><a title="tests.test_ha.test_all_replica_restore_failure" href="#tests.test_ha.test_all_replica_restore_failure">test_all_replica_restore_failure</a></code></li>
<li><code><a title="tests.test_ha.test_auto_remount_with_subpath" href="#tests.test_ha.test_auto_remount_with_subpath">test_auto_remount_with_subpath</a></code></li>
<li><code><a title="tests.test_ha.test_autosalvage_with_data_locality_enabled" href="#tests.test_ha.test_autosalvage_with_data_locality_enabled">test_autosalvage_with_data_locality_enabled</a></code></li>
<li><code><a title="tests.test_ha.test_disable_replica_rebuild" href="#tests.test_ha.test_disable_replica_rebuild">test_disable_replica_rebuild</a></code></li>
<li><code><a title="tests.test_ha.test_dr_volume_with_restore_command_error" href="#tests.test_ha.test_dr_volume_with_restore_command_error">test_dr_volume_with_restore_command_error</a></code></li>
<li><code><a title="tests.test_ha.test_engine_crash_for_dr_volume" href="#tests.test_ha.test_engine_crash_for_dr_volume">test_engine_crash_for_dr_volume</a></code></li>
<li><code><a title="tests.test_ha.test_engine_crash_for_restore_volume" href="#tests.test_ha.test_engine_crash_for_restore_volume">test_engine_crash_for_restore_volume</a></code></li>
<li><code><a title="tests.test_ha.test_engine_image_miss_scheduled_perform_volume_operations" href="#tests.test_ha.test_engine_image_miss_scheduled_perform_volume_operations">test_engine_image_miss_scheduled_perform_volume_operations</a></code></li>
<li><code><a title="tests.test_ha.test_engine_image_not_fully_deployed_perform_auto_upgrade_engine" href="#tests.test_ha.test_engine_image_not_fully_deployed_perform_auto_upgrade_engine">test_engine_image_not_fully_deployed_perform_auto_upgrade_engine</a></code></li>
<li><code><a title="tests.test_ha.test_engine_image_not_fully_deployed_perform_dr_restoring_expanding_volume" href="#tests.test_ha.test_engine_image_not_fully_deployed_perform_dr_restoring_expanding_volume">test_engine_image_not_fully_deployed_perform_dr_restoring_expanding_volume</a></code></li>
<li><code><a title="tests.test_ha.test_engine_image_not_fully_deployed_perform_engine_upgrade" href="#tests.test_ha.test_engine_image_not_fully_deployed_perform_engine_upgrade">test_engine_image_not_fully_deployed_perform_engine_upgrade</a></code></li>
<li><code><a title="tests.test_ha.test_engine_image_not_fully_deployed_perform_replica_scheduling" href="#tests.test_ha.test_engine_image_not_fully_deployed_perform_replica_scheduling">test_engine_image_not_fully_deployed_perform_replica_scheduling</a></code></li>
<li><code><a title="tests.test_ha.test_engine_image_not_fully_deployed_perform_volume_operations" href="#tests.test_ha.test_engine_image_not_fully_deployed_perform_volume_operations">test_engine_image_not_fully_deployed_perform_volume_operations</a></code></li>
<li><code><a title="tests.test_ha.test_ha_backup_deletion_recovery" href="#tests.test_ha.test_ha_backup_deletion_recovery">test_ha_backup_deletion_recovery</a></code></li>
<li><code><a title="tests.test_ha.test_ha_prohibit_deleting_last_replica" href="#tests.test_ha.test_ha_prohibit_deleting_last_replica">test_ha_prohibit_deleting_last_replica</a></code></li>
<li><code><a title="tests.test_ha.test_ha_recovery_with_expansion" href="#tests.test_ha.test_ha_recovery_with_expansion">test_ha_recovery_with_expansion</a></code></li>
<li><code><a title="tests.test_ha.test_ha_salvage" href="#tests.test_ha.test_ha_salvage">test_ha_salvage</a></code></li>
<li><code><a title="tests.test_ha.test_ha_simple_recovery" href="#tests.test_ha.test_ha_simple_recovery">test_ha_simple_recovery</a></code></li>
<li><code><a title="tests.test_ha.test_inc_restoration_with_multiple_rebuild_and_expansion" href="#tests.test_ha.test_inc_restoration_with_multiple_rebuild_and_expansion">test_inc_restoration_with_multiple_rebuild_and_expansion</a></code></li>
<li><code><a title="tests.test_ha.test_rebuild_after_replica_file_crash" href="#tests.test_ha.test_rebuild_after_replica_file_crash">test_rebuild_after_replica_file_crash</a></code></li>
<li><code><a title="tests.test_ha.test_rebuild_failure_with_intensive_data" href="#tests.test_ha.test_rebuild_failure_with_intensive_data">test_rebuild_failure_with_intensive_data</a></code></li>
<li><code><a title="tests.test_ha.test_rebuild_replica_and_from_replica_on_the_same_node" href="#tests.test_ha.test_rebuild_replica_and_from_replica_on_the_same_node">test_rebuild_replica_and_from_replica_on_the_same_node</a></code></li>
<li><code><a title="tests.test_ha.test_rebuild_with_inc_restoration" href="#tests.test_ha.test_rebuild_with_inc_restoration">test_rebuild_with_inc_restoration</a></code></li>
<li><code><a title="tests.test_ha.test_rebuild_with_restoration" href="#tests.test_ha.test_rebuild_with_restoration">test_rebuild_with_restoration</a></code></li>
<li><code><a title="tests.test_ha.test_recovery_from_im_deletion" href="#tests.test_ha.test_recovery_from_im_deletion">test_recovery_from_im_deletion</a></code></li>
<li><code><a title="tests.test_ha.test_replica_failure_during_attaching" href="#tests.test_ha.test_replica_failure_during_attaching">test_replica_failure_during_attaching</a></code></li>
<li><code><a title="tests.test_ha.test_replica_should_not_be_created_when_no_suitable_node_found" href="#tests.test_ha.test_replica_should_not_be_created_when_no_suitable_node_found">test_replica_should_not_be_created_when_no_suitable_node_found</a></code></li>
<li><code><a title="tests.test_ha.test_restore_volume_with_invalid_backupstore" href="#tests.test_ha.test_restore_volume_with_invalid_backupstore">test_restore_volume_with_invalid_backupstore</a></code></li>
<li><code><a title="tests.test_ha.test_retain_potentially_useful_replicas_in_autosalvage_loop" href="#tests.test_ha.test_retain_potentially_useful_replicas_in_autosalvage_loop">test_retain_potentially_useful_replicas_in_autosalvage_loop</a></code></li>
<li><code><a title="tests.test_ha.test_reuse_failed_replica" href="#tests.test_ha.test_reuse_failed_replica">test_reuse_failed_replica</a></code></li>
<li><code><a title="tests.test_ha.test_reuse_failed_replica_with_scheduling_check" href="#tests.test_ha.test_reuse_failed_replica_with_scheduling_check">test_reuse_failed_replica_with_scheduling_check</a></code></li>
<li><code><a title="tests.test_ha.test_salvage_auto_crash_all_replicas" href="#tests.test_ha.test_salvage_auto_crash_all_replicas">test_salvage_auto_crash_all_replicas</a></code></li>
<li><code><a title="tests.test_ha.test_single_replica_failed_during_engine_start" href="#tests.test_ha.test_single_replica_failed_during_engine_start">test_single_replica_failed_during_engine_start</a></code></li>
<li><code><a title="tests.test_ha.test_single_replica_restore_failure" href="#tests.test_ha.test_single_replica_restore_failure">test_single_replica_restore_failure</a></code></li>
<li><code><a title="tests.test_ha.test_single_replica_unschedulable_restore_failure" href="#tests.test_ha.test_single_replica_unschedulable_restore_failure">test_single_replica_unschedulable_restore_failure</a></code></li>
<li><code><a title="tests.test_ha.test_volume_reattach_after_engine_sigkill" href="#tests.test_ha.test_volume_reattach_after_engine_sigkill">test_volume_reattach_after_engine_sigkill</a></code></li>
<li><code><a title="tests.test_ha.wait_pod_for_remount_request" href="#tests.test_ha.wait_pod_for_remount_request">wait_pod_for_remount_request</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
